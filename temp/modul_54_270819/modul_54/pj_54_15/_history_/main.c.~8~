#include <stdbool.h>
#include "risc_runtime/mc30sf.h"
#include "risc_runtime/swic.h"
#include "risc_runtime/risc_interrupt.h"
#include "risc_runtime/system.h"
#include "gigaspwr_reg_fields.hpp"
#include "gigaspwr_misc.hpp"
#include "Convert.h"
#include "DMA_Class.h"
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>


#define GIGASPWR_cl void
#define u64 unsigned long long
#define u32 unsigned int
#define u16 unsigned short
#define u8  unsigned char
#define Bufer_size   1024u   //16384

char Readed_value;
unsigned int tmp_read;

u8 flag_pachka_TXT; //
u16  text_lengh;
u8 text_buffer[Bufer_size];

// USART1 Receiver buffer
#define RX_BUFFER_SIZE0 64u
volatile char          rx_buffer0[RX_BUFFER_SIZE0];
volatile unsigned int rx_wr_index0,rx_rd_index0,rx_counter0;
volatile u8  rx_buffer_overflow0;

#define buf_IO   32u 
#define buf_Word 32u 
#define buf_DATA_Word 200u 
#define BUFFER_SR 64u
#define BUF_STR 64

char sr[BUFFER_SR+1];
unsigned char lsr=0;
unsigned char lk=0;
unsigned int led_tick=0;

#define MAX_PL 157u

char  strng[buf_IO];
char      InOut[BUFFER_SR+1];
char      Word [buf_Word];    //
char DATA_Word [buf_DATA_Word];    //
char DATA_Word2[buf_DATA_Word];    //
 
char Master_flag=0; // 
char Adress=0;  //

u16 lenght=0;
u16 SCH_LENGHT_PACKET=0;
  
unsigned     int index1=0;
unsigned     char crc_ok=0;
unsigned     char packet_ok=0;
unsigned     char packet_flag=0;
unsigned     int indexZ=0; 
unsigned     int index_word=0;
unsigned     int index_data_word=0;
unsigned     int index_data_word2=0;
unsigned     int lenght_data=0;//
unsigned     char data_flag=0;
unsigned     char data_flag2=0;
unsigned     char FLAG_lenght=0;//
unsigned     int sch_lenght_data=0;
unsigned     char FLAG_DATA=0;
unsigned char FLAG_CW=0;
float time_uart=0; //

//---------------------------

unsigned int main_scale = 0x00000036;
//unsigned int SEED = 0x1e2279a0e;
unsigned int PLL_CTR = 0x00000000;
unsigned int ERR_PARAM = 0x00000001;
unsigned int SPEED = 0x00000000;
unsigned int PRINT_EN = 0x00000001;
unsigned int REPORT_EN = 0x00000001;
unsigned int TX_DATA_LENGTH = 0x00001024;
unsigned int SPW_SPEED_MIN = 0x00000010;
unsigned int SPW_SPEED_STEP = 0x00000010;
unsigned int SPW_SPEED_MAX = 0x00000200;
unsigned int GSPW_SPEED_SCALE = 0x00000005;
unsigned int SPW_SPEC_CABLE_PORTS = 0x00000003;


// длина массива в 32-разрядных словах
#define ARRAY_LEN 1000

unsigned int Flag_Timeout = 0;
unsigned int Flag_Corr = 1; // флаг корректности работы теста (0 - корректно, 1 - не корректно)
unsigned int Flag_Disconnect = 0;

volatile unsigned int SWIC_Speed = 0x00000010;
unsigned  int speed;
unsigned  int SWIC_Number = 5;
int errors=0;

unsigned int OutputArray[ARRAY_LEN] __attribute__ ((aligned (8))) = {0,};
unsigned int InputArray[ARRAY_LEN] __attribute__ ((aligned (8))) = {0,};

//-------прототипы функций------------------
u32 IO ( char* );

//------------------------------------------  


void report_high(const char * str)
{

}

volatile struct GIGASPWR_REGS_BASE * REGS = (volatile struct GIGASPWR_REGS_BASE *) 0xB82FA000;
volatile struct GIGASPWR_PMA_TEST_CSR_BASE * PMA_TEST_CSR = (volatile struct GIGASPWR_PMA_TEST_CSR_BASE *) 0xB82FA200;
volatile unsigned int * ROUTING_TABLE = (volatile unsigned int *)0xB82FA400;


void unmask_irq(unsigned int mask) {
  REGS->RISC_IRQ_MASK &= ~mask;
}

void form_routing_table(bool del_header) {
  unsigned int i;
  for ( i=0; i < 16; i++)
    ROUTING_TABLE[i] = (((unsigned int)1 << i) & 0x7f) | 0x080 | ((del_header & 1) << 8);
}

void gspwr_form_adg() {
  report_high("form adg");
  int i;
  for (i = 0; i < 6; i++)
    REGS->ADG[i] = ((unsigned int)2 << i) ;
}

void set_transmit_speed(unsigned int port, int speed, bool pll_en) {
  unsigned int tx_speed;
  switch (port) {
    case port_spw0:
    case port_spw1:
      if (speed == 0)
            speed = GET_GIGASPWR_SPW_TX_SPEED_TX_SPEED(REGS->SPW_TX_SPEED[port]);
      else if (speed >= 5)
            speed = speed / 5;
      if (pll_en)
            speed |= 0x300;
      else
            speed &= ~0x300;
      tx_speed = REGS->SPW_TX_SPEED[port];
          tx_speed = SET_GIGASPWR_SPW_TX_SPEED_TX_SPEED(tx_speed, speed);
      tx_speed = SET_GIGASPWR_SPW_TX_SPEED_TX_SPEED10(tx_speed, speed);
      REGS->SPW_TX_SPEED[port] = tx_speed;
      break;
    case port_gigaspw0:
    case port_gigaspw1:
    case port_gigaspw2:
    case port_gigaspw3:
      if (speed > 0)
        REGS->GIGA_SPW_PMA_MODE[port - port_gigaspw0] = SET_GIGASPWR_GIGA_SPW_PMA_MODE_PMA_TX_SPEED(REGS->GIGA_SPW_PMA_MODE[port - port_gigaspw0], speed);

              tx_speed = REGS->GIGA_SPW_PMA_MODE[port - port_gigaspw0];
              tx_speed = SET_GIGASPWR_GIGA_SPW_PMA_MODE_CDR_MODE(tx_speed, 1);
//               tx_speed = SET_GIGASPWR_GIGA_SPW_PMA_MODE_LB_EN_RX(tx_speed, 1);
//               tx_speed = SET_GIGASPWR_GIGA_SPW_PMA_MODE_LB_EN_TX(tx_speed, 1);
              REGS->GIGA_SPW_PMA_MODE[port - port_gigaspw0] = tx_speed;

      tx_speed = REGS->GIGA_SPW_TX_SPEED[port - port_gigaspw0];
      if (speed < gigasw_speed_312_mhz)
        tx_speed = SET_GIGASPWR_GIGA_SPW_TX_SPEED_KOEFF_COMMA(tx_speed, 1);
      else
        tx_speed = SET_GIGASPWR_GIGA_SPW_TX_SPEED_KOEFF_COMMA(tx_speed, 8);

      tx_speed = SET_GIGASPWR_GIGA_SPW_TX_SPEED_DISCONNECT_COUNTER(tx_speed, 0xf);

      tx_speed = SET_GIGASPWR_GIGA_SPW_TX_SPEED_PWDN_TX(tx_speed, pll_en);
      tx_speed = SET_GIGASPWR_GIGA_SPW_TX_SPEED_PWDN_RX(tx_speed, pll_en);
      tx_speed = SET_GIGASPWR_GIGA_SPW_TX_SPEED_COMMAEN(tx_speed, pll_en);
      tx_speed = SET_GIGASPWR_GIGA_SPW_TX_SPEED_COMPARE_EN(tx_speed, pll_en);
      REGS->GIGA_SPW_TX_SPEED[port - port_gigaspw0] = tx_speed;
      break;
  }
}

//void GIGASPWR_cl::set_recive_speed(unsigned int port, int speed) {
void set_recive_speed(unsigned int port, int speed) {
  switch (port) {
    case port_gigaspw0:
    case port_gigaspw1:
    case port_gigaspw2:
    case port_gigaspw3:
      if (speed > 0)
        REGS->GIGA_SPW_PMA_MODE[port - port_gigaspw0] = SET_GIGASPWR_GIGA_SPW_PMA_MODE_PMA_RX_SPEED(REGS->GIGA_SPW_PMA_MODE[port - port_gigaspw0], speed);
      break;
  }
}

//void GIGASPWR_cl::make_desc(unsigned int *desc_src, int data_len, int route) {
void make_desc(unsigned int *desc_src, int data_len, int route) {
  desc_src[0] = 0xA0000000 + (data_len & 0x0fffffff);
  desc_src[1] = route;
}

//void GIGASPWR_cl::set_dma_enabled(bool dma_en) {
void set_dma_enabled(bool dma_en) {
  REGS->MODE_R = SET_GIGASPWR_MODE_R_DMA_ENABLED(REGS->MODE_R, dma_en);
}

//void GIGASPWR_cl::set_work_enabled(bool work_en) {
void set_work_enabled(bool work_en) {
  REGS->MODE_R = SET_GIGASPWR_MODE_R_MAIN_KOEFF10(REGS->MODE_R, 0xb);
  REGS->MODE_R = SET_GIGASPWR_MODE_R_GIGASPWR_WE(REGS->MODE_R, work_en);
}

//void GIGASPWR_cl::start_connect(unsigned int port) {
void start_connect(unsigned int port) {
  unsigned int spw_mode;

  if (port > port_max_numb)
    return;

  spw_mode = REGS->SPW_MODE[port];
  spw_mode = SET_GIGASPWR_SPW_MODE_LINKSTART(spw_mode, 1);
//   spw_mode = SET_GIGASPWR_SPW_MODE_AUTO_SPEED_MODE(spw_mode, 1);
  spw_mode = SET_GIGASPWR_SPW_MODE_LINKDISABLED(spw_mode, 0);
  spw_mode = SET_GIGASPWR_SPW_MODE_BDS_RESET(spw_mode, 1);
  spw_mode = SET_GIGASPWR_SPW_MODE_AUTOSTART(spw_mode, 1);
  spw_mode = SET_GIGASPWR_SPW_MODE_D_INT_ACK_REGIMES(spw_mode, 0);
  spw_mode = SET_GIGASPWR_SPW_MODE_INT_CODES(spw_mode, 0);
  spw_mode = SET_GIGASPWR_SPW_MODE_ACK_CODES(spw_mode, 0);

  REGS->SPW_MODE[port] = spw_mode;
}

//unsigned int GIGASPWR_cl::get_status(unsigned int port, bool print) {
unsigned int get_status(unsigned int port, bool print) {
  unsigned int ds_state;

  if (port > port_max_numb)
    return 0xFFFFFFFF;

  ds_state = GET_GIGASPWR_SPW_STATUS_BDS_STATE(REGS->SPW_STATUS[port]);

  if (print) {
    switch (ds_state) {
      case link_status_err_reset:
        report_high("Error Reset");
        break;
      case link_status_err_wait:
        report_high("Error Wait");
        break;
      case link_status_ready:
        report_high("Ready");
        break;
      case link_status_started:
        report_high("Started");
        break;
      case link_status_connecting:
        report_high("Connecting");
        break;
      case link_status_run:
        report_high("Run");
        break;
      default:
        report_high("Unknown Status");
    }
  }
  return ds_state;
}


//int GIGASPWR_cl::wait_link_status(unsigned int port, unsigned int status, unsigned int timeout) {
int wait_link_status(unsigned int port, unsigned int status, unsigned int timeout) {
  unsigned int t = 0;
  //while (this->get_status(port, false) != status) {
  while (get_status(port, false) != status) {
    if ((++t >= timeout) && (timeout != 0)) {
      report_high("timeout reached");
      return 1;
    }
  }
  return 0;
}

//unsigned int GIGASPWR_cl::get_rx_speed(unsigned int port) {
unsigned int get_rx_speed(unsigned int port) {
  return REGS->SPW_RX_SPEED[port];
}

//,==== SpW_bridge_mcom02 - Мост для ретрансляции данных на портах Space Wire от другого устройства (mcom02) ====
unsigned int check_SpW_link_status_run(GIGASPWR_cl* gigaspwr, unsigned int SpW_port_n) {
  //unsigned int cur_link_status = gigaspwr->get_status(SpW_port_n, false);
  unsigned int cur_link_status = get_status(SpW_port_n, false);
  if (cur_link_status != link_status_run) {
    //report_error("Error link_status_run [SpW_port_n / cur_link_status]:");
    //print_val(SpW_port_n);
    //print_val(cur_link_status);
    return 1;
  }
  return 0;
}

void turn_off(unsigned int port){
  unsigned int spw_mode;

  if (port > port_max_numb)
    return;

  spw_mode = REGS->SPW_MODE[port];
  spw_mode = SET_GIGASPWR_SPW_MODE_LINKSTART(spw_mode, 0);
  spw_mode = SET_GIGASPWR_SPW_MODE_LINKDISABLED(spw_mode, 1);
  spw_mode = SET_GIGASPWR_SPW_MODE_BDS_RESET(spw_mode, 1);
  REGS->SPW_MODE[port] = spw_mode;

  spw_mode = REGS->STATE_R;
  spw_mode = SET_GIGASPWR_STATE_R_PORT_CONNECTED(spw_mode, 0x3f);
  spw_mode = SET_GIGASPWR_STATE_R_PORT_ERRORED(spw_mode, 0x3f);
  REGS->STATE_R = spw_mode;

  set_transmit_speed(port, 0, false);
  set_dma_enabled(false);
  set_work_enabled(false);
}


void FillArray(unsigned int *array, unsigned int len, int first) {
        unsigned int i;
        array[0] = 0; // Always config
        for (i=1;i<len;i++) {
                array[i] = i-1+first;
        }
}

int VerifyArray(unsigned int *array, unsigned int len, int first) {
        unsigned int i;
        if (array[0] != 0) return 0;
        for (i=1;i<len;i++) {
                if(array[i] != i-1+first) return 0;
        }
        return 1;
}

void timer_hnlr(int a)
{
  Flag_Timeout = 1;
  unsigned int param= 0;
  asm volatile ("mtc0 %0, $11" : : "r"(param));
  asm volatile ("nop");
  asm volatile ("break 0x0, 0x1");
  asm volatile ("nop");
}

void dc_hnlr(int a)
{
  Flag_Disconnect = 1;
  asm volatile ("nop");
  asm volatile("break 0x0, 0x1");
  asm volatile ("nop");
}

//---------------------------------

/* reverse:  переворачиваем строку s на месте */
 void reverse(char s[])
 {
     int i, j;
     char c;

     for (i = 0, j = strlen(s)-1; i<j; i++, j--) {
         c = s[i];
         s[i] = s[j];
         s[j] = c;
     }
 }

 /* itoa:  конвертируем n в символы в s */
 void itoa(int n, char s[])
 {
     int i, sign;

     if ((sign = n) < 0)  /* записываем знак */
         n = -n;          /* делаем n положительным числом */
     i = 0;
     do {       /* генерируем цифры в обратном порядке */
         s[i++] = n % 10 + '0';   /* берем следующую цифру */
     } while ((n /= 10) > 0);     /* удаляем */
     if (sign < 0)
         s[i++] = '-';
     s[i] = '\0';
     reverse(s);
 }


// Инициализация UART
// варьируется только скорость обмена
// остальные параметры не задаются
// длина слова - 8 бит
// стоп-бит - 1
// четность не контролируется
// управление потоком данных отсутствует
// BaudRate - скорость обмена
// Freq - частота процессора
void UART_conf(int BaudRate, int Frq) {
      int dlm;

      dlm = (Frq)/(BaudRate*16);

      UART0_LCR = (int)0x80;
      UART0_SCLR  = 0;
      UART0_DLL   = dlm&0xFF;
      UART0_DLM   = (dlm>>8);
      UART0_LCR   = 3;

} // UART_conf


void UART_sendByte(char Sym) {
// пишем символ в порт
     UART0_THR = Sym;
// ждем, пока он будет отправлен
    while ( ( UART0_LSR & 0x60 ) != 0x60 ) ;
}// UART_sendByte

char UART_receiveByte() {
   char Readed_value;
 // ждем, пока на RBR что-то появится
   while ( ( UART0_LSR & 0x01) != 0x01);
   Readed_value = UART0_RBR;
   return Readed_value;
}


 void Transf(char *Str)
 {
       while (*Str != 0)
          UART_sendByte(*Str++);
 }

void u_out (char s[],u32 a)
{
   Transf (s);
   itoa (a,strng);
// sprintf (strng,"%u",a);
   Transf(strng);
   Transf ("\r");
}

// функция обработчика

void int_handler() 
{
    tmp_read = UART0_IIR;

   rx_buffer0[rx_wr_index0++]= UART0_RBR; //считываем данные в буфер, инкрементируя хвост буфера
   if ( rx_wr_index0 == RX_BUFFER_SIZE0) rx_wr_index0=0; //идем по кругу
     
    if (++rx_counter0 == RX_BUFFER_SIZE0) //переполнение буфера
      {
        rx_counter0=0; //начинаем сначала (удаляем все данные)
        rx_buffer_overflow0=1;  //сообщаем о переполнении
      }    
}

// разрешение прерывания внутри UART
void IER_UART() {

	UART0_IER = UART0_IER|0x01;// ERBI Разрешение прерывания по наличию принятых данных (RDAI), а также по таймауту (CTI)

}

char getchar0(void)
{
   u8 data;
   while (rx_counter0 == 0);
   data = rx_buffer0[ rx_rd_index0++ ];
   if (rx_rd_index0 == RX_BUFFER_SIZE0) rx_rd_index0 = 0;
    --rx_counter0;
    return data;
}


void UART_conrol (void)
{
 u16 i=0;
 u16 j=0;

  if (rx_counter0!=0u)
    {   
      if (rx_counter0<BUFFER_SR) j = rx_counter0; else j=BUFFER_SR;

      for (i=0u;i<j; i++) 
         {
           sr[i]=getchar0();
           lenght=i+1;  
           if (sr[i]==';') {break;}
          }
            sr[lenght]=0x00;
            //Transf("*");
            IO (sr);
        };
}


u8 leng ( char *s)
{
  u8 i=0;

   while ((s[i]!='\0')&&(i<120)) { i++;}

  return i;
}


void GPIO_conf()
{
      DIR_MFBSP3 = 0xff;   // переключаем LDAT[7:0] в режим выхода
      GPIO_DR3 = 0xff;
} // GPIO_conf

// диод включен
 void LED(u8 a) {
      GPIO_DR3 =a;
 } //LED_on


void Menu1()
 
 {
//***************************************************************************

    int i;
  
 
  for (i=0;i<20;i++) Transf("\r");    // очистка терминала
  for (i=0; i<20; i++) Transf ("-");  // вывод приветствия
  Transf("\r");
  Transf("..........Terminal Тестовой платы.........\r\n");
  Transf("\r");
  Transf("MENU :\r");
  Transf("-------\r");
  Transf("Расшифровка структуры команды:\r");
  Transf("~ - стартовый байт\r");
  Transf("1 - адрес абонента\r");
  Transf(";- конец пачки \r");
  Transf(".............. \r");
  Transf("---------------------------------------------\r\n");
  Transf("IP  :192.168.1.163 - IP адрес    блока\r");
  Transf("PORT:2054          - номер порта блока\r");
  Transf("~0 help; - текущее меню\r");
  Transf("~0 info; - информация \r");
  Transf("~0 dac1_init; - \r");
  Transf("~0 dac1_r:0;   - чтение регистра\r");
  Transf("~0 dac1_w:0.0; - запись регистра\r");
  Transf("~0 dac1_serdes_pll:1; - очистка регистра сигнала захвата PLL Serdes\r");
  Transf("~0 dac1_info:0; \r");
  Transf("~0 dac1_init:0; \r");
  Transf("~0 dac1_phy_wr:0; \r");
  Transf("~0 dac1_phy_info; \r");
  Transf("~0 lmk_sync; - sync на LMK\r");
  Transf("~0 init_lmk; - init на LMK\r");
  Transf("-------------------------------------------\r");
  Transf("\r");
  Transf("\r");
  Transf("++++++++++++++++++++\r");
  Transf("\r");
  Transf("\r");
  //for (i=0; i<64; i++) zputs ("*",1);  // вывод приветствия
  //for (i=0;i<10;i++) puts("\r",1);  // очистка терминала
  Transf("\r");
  //*******************************************************************************
}


u32 crc_input=0u; 
u32 crc_comp=0u;

u32 IO ( char* str)      // функция обработки протокола обмена
{

 unsigned int i=0;

  i = lenght;//длинна принятой пачки
  if (lenght==0) i = leng(str);
  lenght = 0;
  indexZ = 0;
 
  while (i>0u)   //перегрузка принятого пакета в массив обработки
  {    
    

  if ((str[indexZ]==0x7e)&&(packet_flag==0))// обнаружено начало пакета
    {  
    //-------------------
    packet_flag=1; 
    //-------------------
    time_uart=0u;  //обнуление счётчика тайм аута
    index1=0u; 
    crc_ok=0; 
    packet_ok=0; 
    index_word=0u; 
    index_data_word =1u;
    index_data_word2=1u;
    data_flag =0;
    data_flag2=0;
      FLAG_lenght=0u;
      lenght_data=0u;
      sch_lenght_data=0u;
    DATA_Word [0]=' ';
    DATA_Word2[0]=' ';
      FLAG_CW = 0u; //флаг управляющего байта, снимается сразу после исполнения
    FLAG_DATA = 0u;
    SCH_LENGHT_PACKET=0;
    
    }

   InOut[index1]=str[indexZ];
   SCH_LENGHT_PACKET++;//подсчитываем длинну пакета
     
  if (( InOut[index1]==';')&&(FLAG_DATA==0u)&&(packet_flag==1))  {packet_flag=0;packet_ok=1u;FLAG_CW=1u;}
    
  if (((InOut[index1]=='=')||(InOut[index1]==':'))&&(data_flag==0)) {data_flag=1u;FLAG_CW=1u;}

  if (( InOut[index1]=='.')&&(data_flag2==0)&&(FLAG_DATA==0))   {data_flag2=1u; FLAG_CW=1u;}
  
  if (( InOut[index1]=='$')&&(FLAG_lenght==0u)) {FLAG_lenght=2u;FLAG_CW=1u;}
    
  if ((index1>2u)&&(InOut[2]==' ')&&(FLAG_CW==0u)&&(FLAG_lenght<2u))  
            {
                             if   (data_flag!=1u) {Word[index_word]=InOut[index1];} // заполняем командное слово
                      
                             if  ((data_flag==1u)&&(data_flag2==0u))     DATA_Word[index_data_word]=InOut[index1];// заполняем  слово данных1
                             if  ((data_flag==1u)&&(data_flag2==1u))     DATA_Word2[index_data_word2]=InOut[index1]; // заполняем  слово данных2
                    
                             if  (data_flag!=1u)
                                     {if (index_word<buf_Word) index_word++;} 
                                   else 
                                            {
                                             if ((data_flag==1u)&&(data_flag2==0u)) if (index_data_word<buf_DATA_Word)  {index_data_word++;sch_lenght_data++;}
                                            
                                             if ((data_flag==1u)&&(data_flag2==1u)) if (index_data_word2<buf_DATA_Word) index_data_word2++;
                                            }
      }
  
    if ((FLAG_lenght==2u)&&(FLAG_CW==0u)) {lenght_data = (u8)(InOut[index1]);FLAG_lenght=1u;} //запоминаем длинну пакета данных после ":"
  
    if ((sch_lenght_data<lenght_data)&&(FLAG_lenght==1u)) FLAG_DATA = 1u; else {FLAG_DATA = 0u;}
   
    if (index1<BUFFER_SR)  index1++;
    if (indexZ <BUFFER_SR)  indexZ ++;
    i--;
    FLAG_CW=0u;
  
  }
 

if (packet_ok==1u) 
  {    
      if (InOut[0]==0x7e)   crc_ok=crc_ok|0x1;   // проверка первого условия пакета - начало пакета
      if (InOut[1]==Adress) crc_ok=crc_ok|0x2;   // проверка второго условия пакета - адресат назначения
 
if (crc_ok==0x3)  //обработка команд адресатом которых является хозяин
{

 
if (strcmp(Word,"help")==0)                     
   {
     Transf ("принял help\r"    );
     Transf("\r");  
     Menu1(0);
   } else
if (strcmp(Word,"help2")==0)                     
   {
     Transf ("принял help\r"    );
     Transf("\r");  
   } else
if (strcmp(Word,"info")==0)                     
   {
     Transf ("принял info\r"    );
     Transf("\r");  
     //info();
   } else

if (strcmp(Word,"menu")==0)                     
   {
     Transf ("принял menu\r"    );
     Transf("\r");  
     Menu1();
   } else
if (strcmp(Word,"upr_at1")==0) //
   {
  crc_comp =atoi(DATA_Word);
    
  u_out ("принял upr_at1:",crc_comp);
                       
    } else
if (strcmp(Word,"upr_at2")==0) //
   {
  crc_comp =atoi(DATA_Word);
    
  u_out ("принял upr_at2:",crc_comp);
                     
    } else    
             
if (strcmp(Word,"test_spi_read")==0) //
   {
  crc_comp =atoi(DATA_Word);
  crc_input=atoi(DATA_Word2);
        
  u_out ("принял test_spi_read:",crc_comp);
                         
   } else  
//-------------------ADC2------------------------------    
if (strcmp(Word,"adc2_read_reg")==0) //
   {
  u_out ("принял adc2_read_reg:",0);
                        
   } else 
if (strcmp(Word,"adc2_init")==0) //
   {
  u_out ("принял adc2_init:",0);
                        
   } else
//-------------------ADC1------------------------------    
if (strcmp(Word,"adc1_read_reg")==0) //
   {
  u_out ("принял adc1_read_reg:",0);
                         
   } else 
if (strcmp(Word,"adc1_init")==0) //
   {
  u_out ("принял adc1_init:",0);
                       
   }
      } 
    for (i=0u;i<buf_Word;i++)               Word[i]     =0x0;
      for (i=0u;i<buf_DATA_Word;  i++)   DATA_Word[i]     =0x0;
      for (i=0u;i<buf_DATA_Word;  i++)  DATA_Word2[i]     =0x0;  
      for (i=0u;i<BUFFER_SR;i++)  
      {
        InOut[i]     =0x0;
      }  
      
      time_uart=0;  //обнуление счётчика тайм аута
      packet_flag=0; 
      index1=0u; 
      crc_ok=0; 
      i=0;
      packet_ok=0; 
      index_word=0u; 
      index_data_word=0u;
      data_flag=0;
      index_data_word2=0u;
      data_flag2=0;
      indexZ =0u;
      FLAG_lenght=0u;
      lenght_data=0u;
      sch_lenght_data=0u;
      FLAG_CW = 0u; //флаг управляющего байта, снимается сразу после исполнения
      FLAG_DATA = 0u;   
          
      DATA_Word [0]=' ';
      DATA_Word2[0]=' ';
    SCH_LENGHT_PACKET=0;
  }

  if ((packet_ok==1)&&(crc_ok==0x1))     //обработка команд адресатом которых является слейв

  {
    
    if (Master_flag==0)

      {            
         
      }
  }
  
  return  0;
         
} 
//---------------------------------

int sch;

void main()
{
 //---------------------------------------------------
char readed;
        CLK_EN = 0xFFFFFFFF; // включение тактовой частоты
        CR_PLL0 = 0xb01298;   // коэффициент умножения входной частоты PLL_DSP - 48   (240 МГц)
                             // коэффициент умножения входной частоты PLL_MPORT - 18 (90 МГц)
                             // коэффициент умножения входной частоты PLL_CORE - 48  (240 МГц)
 UART_conf(115200,120000000);

 GPIO_conf();
 LED(0xff);

 //***********************************
	
 Transf("------------------------\n\r");
 Transf("-   Многоцветник-54    -\n\r");
 Transf("------------------------\n\r");
 
Adress=0x30; //адресс кассеты
 sch=0;


 rx_counter0 =0;
 rx_rd_index0=0;
 rx_wr_index0=0;
 rx_buffer_overflow0=0;     

      
//       while (1) {
            // читаем символ из приемного буферного регистра RBR
//           readed  =UART_receiveByte();
            // отправляем полученный символ в передающий буферный регистр THR
//           UART_sendByte(readed);
//          }
//-----------------------------------------------------

  risc_set_interrupts_vector(INTH_80000180);
  SYS_CSR |= 2;
  risc_register_interrupt(int_handler, RISC_INT_UART0);
  IER_UART();

// запускаем подсчёт времени для таймаута
  unsigned int param = get_cpu_clock();
  param *= 5;
  asm volatile ("mtc0 %0, $11" : : "r"(param));
  param= 0;
  asm volatile ("mtc0 %0, $9" : : "r"(param));

  risc_enable_interrupt(RISC_INT_UART0);


   while (1)
  {
    
    UART_conrol();

  }

/*

  risc_set_interrupts_vector(INTH_80000180);
  SYS_CSR |= 2;

  risc_register_interrupt(timer_hnlr, RISC_COMPARE);
  // Работаем без прерываний от gsw
  assign_dma_rx_desc((struct DMA_PORT_CH_cl *) 0xb82fa800);
  assign_dma_rx_data((struct DMA_PORT_CH_cl *) 0xb82fa840);
  assign_dma_tx_desc((struct DMA_PORT_CH_cl *) 0xb82fa880);
  assign_dma_tx_data((struct DMA_PORT_CH_cl *) 0xb82fa8C0);

  // запускаем подсчёт времени для таймаута
  unsigned int param = get_cpu_clock();
  param *= 5;
  asm volatile ("mtc0 %0, $11" : : "r"(param));
  param= 0;
  asm volatile ("mtc0 %0, $9" : : "r"(param));

  risc_enable_interrupt(RISC_COMPARE);

  int transmitter, receiver;
  transmitter = 0;
  receiver = 1;
  //SWIC_Speed = SPW_SPEED_MIN;

  // Подготовка соединений
  // cable_test_start
  unmask_irq(gigaspwr_irq_all);
  form_routing_table(false);
  gspwr_form_adg();
  set_transmit_speed(port_spw0, 5, true);
  set_transmit_speed(port_spw1, 5, true);
     set_recive_speed(port_gigaspw2, gigasw_speed_125_mhz);
     set_transmit_speed(port_gigaspw3, gigasw_speed_125_mhz, true);
     set_recive_speed(port_gigaspw3, gigasw_speed_125_mhz);
     set_transmit_speed(port_gigaspw2, gigasw_speed_125_mhz, true);
  REGS->SPW_MODE[port_gigaspw2] = SET_GIGASPWR_SPW_MODE_CODEC_LOOPBACK(REGS->SPW_MODE[port_gigaspw2], 1);
  REGS->SPW_MODE[port_gigaspw3] = SET_GIGASPWR_SPW_MODE_CODEC_LOOPBACK(REGS->SPW_MODE[port_gigaspw3], 1);

  
  // Это делаем по другому алгоритму
  //memory_agent.fill_mem_block_rand(TX_Data, TX_DATA_LENGTH << 1, rand()); // генерация пакета (ов?)
  //TX_Data[0] = 0;                        // always to conf port           // ?
  //TX_Data[TX_DATA_LENGTH >> 2] = 0;        // always to conf port         // в словах?
  //make_desc(TX_Desc, TX_DATA_LENGTH, route_mask_spw0);
  //make_desc(&TX_Desc[2], TX_DATA_LENGTH, route_mask_spw1);
  
  set_dma_enabled(true);
  set_work_enabled(true);

  start_connect(port_spw0);
  start_connect(port_spw1);
     start_connect(port_gigaspw2);
     start_connect(port_gigaspw3);
  // Ожидание соединения
  int port_i;
  for (port_i = port_spw0; port_i <= port_spw1; port_i++)
     if (SPW_SPEC_CABLE_PORTS & (1 << port_i))
        {
	wait_link_status(port_i, link_status_run, 0);
        }
  speed = SWIC_Speed;
  //,# Для Spw переход на рабочую скорость
  // Скорость передачи устанавливаем один раз
  for (port_i = port_spw0; port_i <= port_spw1; port_i++)
      if (SPW_SPEC_CABLE_PORTS & (1 << port_i))
          set_transmit_speed(port_i, speed, true);

  //,# Ожидание разгона PLL
  for (port_i = port_spw0; port_i <= port_spw1; port_i++)
       if (SPW_SPEC_CABLE_PORTS & (1 << port_i)) {
         while (get_rx_speed(port_i) < speed - 3);
         //,# Проверка, что соединение не разорвалось
         errors += check_SpW_link_status_run((GIGASPWR_cl*)0, port_i);
       }
  if (errors)
      {
      Flag_Corr = 1; // соединение разорвалось
      asm volatile("break 0x0, 0x1");
      }


  // cable_test_end

  risc_disable_interrupt(RISC_COMPARE);

  int size = ARRAY_LEN*sizeof(int);
  int i=0;
  int corr_counter = 0;


  unsigned int descr[2]__attribute__ ((aligned(8))) = {0};

  int l_port;
  for (i=0; i<SWIC_Number; i++)
  {
      swic_receiver_run(receiver, InputArray, descr, 0xFFFF);    // +
      FillArray(OutputArray,ARRAY_LEN,i);                        // +
      if (transmitter)
          l_port = route_mask_spw1;
      else
          l_port = route_mask_spw0;
      swic_send_packet(l_port, OutputArray, size, 1);            // +
      swic_receiver_wait(receiver);                              // + // - port check?
      corr_counter += VerifyArray(InputArray,ARRAY_LEN,i);       // +
      transmitter ^= 1;
      receiver ^= 1;
  }
  */

 LED(0x00);

 Transf("------------------------\n\r");
 Transf("-        THE END       -\n\r");
 Transf("------------------------\n\r");

 // if (corr_counter == SWIC_Number) Flag_Corr = 0;
 // asm volatile("break 0x0, 0x1");
}

