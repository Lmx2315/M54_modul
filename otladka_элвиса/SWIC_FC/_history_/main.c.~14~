#include <stdbool.h>
#include "risc_runtime/mc30sf.h"
#include "risc_runtime/swic.h"
#include "risc_runtime/risc_interrupt.h"
#include "risc_runtime/system.h"
#include "gigaspwr_reg_fields.hpp"
#include "gigaspwr_misc.hpp"
#include "Convert.h"
#include "DMA_Class.h"
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include "global_var.h"

#define GIGASPWR_cl void
#define u64 unsigned long long
#define u32 unsigned int
#define u16 unsigned short
#define u8  unsigned char
#define Bufer_size   1024u   //16384

#define RESET 0u
#define SET   1u

//дефайны 2 порта
#define P2LDAT0_0 init_GPIO_DR2(0x01,RESET)
#define P2LDAT0_1 init_GPIO_DR2(0x01,  SET)

#define P2LDAT1_0 init_GPIO_DR2(0x02,RESET)
#define P2LDAT1_1 init_GPIO_DR2(0x02,  SET)

#define P2LDAT2_0 init_GPIO_DR2(0x04,RESET)
#define P2LDAT2_1 init_GPIO_DR2(0x04,  SET)

#define P2LDAT3_0 init_GPIO_DR2(0x08,RESET)
#define P2LDAT3_1 init_GPIO_DR2(0x08,  SET)

#define P2LDAT4_0 init_GPIO_DR2(0x10,RESET)
#define P2LDAT4_1 init_GPIO_DR2(0x10,  SET)

#define P2LDAT5_0 init_GPIO_DR2(0x20,RESET)
#define P2LDAT5_1 init_GPIO_DR2(0x20,  SET)

#define P2LDAT6_0 init_GPIO_DR2(0x40,RESET)
#define P2LDAT6_1 init_GPIO_DR2(0x40,  SET)

#define P2LDAT7_0 init_GPIO_DR2(0x80,RESET)
#define P2LDAT7_1 init_GPIO_DR2(0x80,  SET)

//дефайны 3 порта
#define P3LDAT0_0 init_GPIO_DR3(0x01,RESET)
#define P3LDAT0_1 init_GPIO_DR3(0x01,  SET)

#define P3LDAT1_0 init_GPIO_DR3(0x02,RESET)
#define P3LDAT1_1 init_GPIO_DR3(0x02,  SET)

#define P3LDAT2_0 init_GPIO_DR3(0x04,RESET)
#define P3LDAT2_1 init_GPIO_DR3(0x04,  SET)

#define P3LDAT3_0 init_GPIO_DR3(0x08,RESET)
#define P3LDAT3_1 init_GPIO_DR3(0x08,  SET)

#define P3LDAT4_0 init_GPIO_DR3(0x10,RESET)
#define P3LDAT4_1 init_GPIO_DR3(0x10,  SET)

#define P3LDAT5_0 init_GPIO_DR3(0x20,RESET)
#define P3LDAT5_1 init_GPIO_DR3(0x20,  SET)

#define P3LDAT6_0 init_GPIO_DR3(0x40,RESET)
#define P3LDAT6_1 init_GPIO_DR3(0x40,  SET)

#define P3LDAT7_0 init_GPIO_DR3(0x80,RESET)
#define P3LDAT7_1 init_GPIO_DR3(0x80,  SET)


#define TST2(a)     ((a==1)?P2LDAT0_1:P2LDAT0_0)
#define A2_CSB(a)   ((a==1)?P2LDAT1_1:P2LDAT1_0)
//#define A2_SO(a)    ((a==1)?P2LDAT2_1:P2LDAT2_0)
#define A2_SPLIN(a) ((a==1)?P2LDAT3_1:P2LDAT3_0)
#define A2_PWRDN(a) ((a==1)?P2LDAT4_1:P2LDAT4_0)
#define AT1_5(a)    ((a==1)?P2LDAT5_1:P2LDAT5_0)
#define AT1_6(a)    ((a==1)?P2LDAT6_1:P2LDAT6_0)

#define PF1_SYNC_START(a)    ((a==1)?P2LDAT7_1:P2LDAT7_0)


#define TST1(a)     ((a==1)?P3LDAT0_1:P3LDAT0_0)
#define A1_CSB(a)   ((a==1)?P3LDAT1_1:P3LDAT1_0)
//#define A1_SO(a)    ((a==1)?P3LDAT2_1:P3LDAT2_0)
#define A1_SPLIN(a) ((a==1)?P3LDAT3_1:P3LDAT3_0)
#define A1_PWRDN(a) ((a==1)?P3LDAT4_1:P3LDAT4_0)

#define RST_1288(a) ((a==1)?P3LDAT7_1:P3LDAT7_0)

char Readed_value;
unsigned int tmp_read;

u8 flag_pachka_TXT; //
u16  text_lengh;
u8 text_buffer[Bufer_size];

// USART1 Receiver buffer
#define RX_BUFFER_SIZE0 64u
volatile char          rx_buffer0[RX_BUFFER_SIZE0];
volatile unsigned int rx_wr_index0,rx_rd_index0,rx_counter0;
volatile u8  rx_buffer_overflow0;

#define buf_IO   32u
#define buf_Word 32u
#define buf_DATA_Word 200u
#define BUFFER_SR 64u
#define BUF_STR 64

char sr[BUFFER_SR+1];
unsigned char lsr=0;
unsigned char lk=0;
unsigned int led_tick=0;

#define MAX_PL 157u

char  strng[buf_IO];
char      InOut[BUFFER_SR+1];
char      Word [buf_Word];    //
char DATA_Word [buf_DATA_Word];    //
char DATA_Word2[buf_DATA_Word];    //

char Master_flag=0; //
char Adress=0;  //

u16 lenght=0;
u16 SCH_LENGHT_PACKET=0;

unsigned     int index1=0;
unsigned     char crc_ok=0;
unsigned     char packet_ok=0;
unsigned     char packet_flag=0;
unsigned     int indexZ=0;
unsigned     int index_word=0;
unsigned     int index_data_word=0;
unsigned     int index_data_word2=0;
unsigned     int lenght_data=0;//
unsigned     char data_flag=0;
unsigned     char data_flag2=0;
unsigned     char FLAG_lenght=0;//
unsigned     int sch_lenght_data=0;
unsigned     char FLAG_DATA=0;
unsigned char FLAG_CW=0;
float time_uart=0; //

//---------------------------

unsigned int main_scale = 0x00000036;
//unsigned int SEED = 0x1e2279a0e;
unsigned int PLL_CTR = 0x00000000;
unsigned int ERR_PARAM = 0x00000001;
unsigned int SPEED = 0x00000000;
unsigned int PRINT_EN = 0x00000001;
unsigned int REPORT_EN = 0x00000001;
unsigned int TX_DATA_LENGTH = 0x00001024;
unsigned int SPW_SPEED_MIN = 0x00000010;
unsigned int SPW_SPEED_STEP = 0x00000010;
unsigned int SPW_SPEED_MAX = 0x00000200;
unsigned int GSPW_SPEED_SCALE = 0x00000005;
unsigned int SPW_SPEC_CABLE_PORTS = 0x00000003;


// длина массива в 32-разрядных словах
#define ARRAY_LEN 1000

unsigned int Flag_Timeout = 0;
unsigned int Flag_Corr = 1; // флаг корректности работы теста (0 - корректно, 1 - не корректно)
unsigned int Flag_Disconnect = 0;

volatile unsigned int SWIC_Speed = 0x00000010;
unsigned  int speed;
unsigned  int SWIC_Number = 5;
int errors=0;

unsigned int OutputArray[ARRAY_LEN] __attribute__ ((aligned (8))) = {0,};
unsigned int InputArray[ARRAY_LEN] __attribute__ ((aligned (8))) = {0,};

//-------прототипы функций------------------
u32 IO ( char* );
void Transf(const char *);
u32 spi (u32 );
u32 spi_1288_rd (u16 );
u32 spi_1288_wr (u16 ,u16 );
//------------------------------------------

//--------------------------
typedef struct  reg_1288  // объявляю структуру
{
	u32 R[128];

    u16 SWRST           :16;//Регистр программного сброса
	u16 DEVID           :16;//Идентификатор устройства, только чтение
	u16 INT				:16;//Флаги прерываний
	u16 INTE			:16;//Маска флагов прерываний
	u16 INTR			:16;//Регистр сброса прерываний
	u16 SYNC			:16;//Регистр управления синхронизацией
	u16 ADC_OVF			:16;//Регистр флагов перегрузки АЦП, сбрасывается при чтении
	u16 ADC_CFG			:16;//Регистр управления источниками входных сигналов
	u16 RX_CFG			:16;//Регистр общей конфигурации каналов приема
	u16 RX_FIFO_THRESH	:16;//Порог флага PF - заполненность буфера приемных каналов
	u16 RX_LINK			:16;//Регистр управления линк-портом приемных каналов

	u16 RX1				:16;//Регистры первого канала приема
	u16 RX1_OVF			:16;//Регистр флагов переполнения, сбрасывается при чтении
	u16 RX1_LCFG		:16;//Регистр конфигурации отдельного канала
	u16 RX1_DCIC2		:16;//Регистр конфигурации первой ступени CIC-дециматоров
	u16 RX1_DCICN		:16;//Регистр конфигурации второй ступени CIC-дециматоров
	u16 RX1_DFIR1_CFG1	:16;//Регистр конфигурации 1 первого КИХ-фильтра-дециматора
	u16 RX1_DFIR1_CFG2 	:16;//Регистр конфигурации 2 первого КИХ-фильтра-дециматора
	u16 RX1_DFIR2_CFG1	:16;//Регистр конфигурации 1 второго КИХ-фильтра-дециматора
	u16 RX1_DFIR2_CFG2 	:16;//Регистр конфигурации 2 второго КИХ-фильтра-дециматора
	u16 RX1_GAIN_I		:16;//Регистр установки “точного” комплексного коэффициента усиления (I компонента)
	u16 RX1_GAIN_Q		:16;//Регистр установки “точного” комплексного коэффициента усиления (Q компонента)
	u16 RX1_NCO_PHASE	:16;//Регистр начальной фазы гетеродина
	u16 RX1_NCO_FRQL	:16;//Регистр частоты гетеродина, младшие 16 разрядов
	u16 RX1_NCO_FRQH	:16;//Регистр частоты гетеродина, старшие 16 разрядов
	u16 RX1_CF_DFIR1[64];//Коэффициенты первого DFIR фильтра-дециматора
	u16 RX1_CF_DFIR2[64];//Коэффициенты второго DFIR фильтра-дециматора

	u16 RX2				:16;//Регистры второго канала приема
	u16 RX2_OVF			:16;//Регистр флагов переполнения, сбрасывается при чтении
	u16 RX2_LCFG		:16;//Регистр конфигурации отдельного канала
	u16 RX2_DCIC2		:16;//Регистр конфигурации первой ступени CIC-дециматоров
	u16 RX2_DCICN		:16;//Регистр конфигурации второй ступени CIC-дециматоров
	u16 RX2_DFIR1_CFG1	:16;//Регистр конфигурации 1 первого КИХ-фильтра-дециматора
	u16 RX2_DFIR1_CFG2 	:16;//Регистр конфигурации 2 первого КИХ-фильтра-дециматора
	u16 RX2_DFIR2_CFG1	:16;//Регистр конфигурации 1 второго КИХ-фильтра-дециматора
	u16 RX2_DFIR2_CFG2 	:16;//Регистр конфигурации 2 второго КИХ-фильтра-дециматора
	u16 RX2_GAIN_I		:16;//Регистр установки “точного” комплексного коэффициента усиления (I компонента)
	u16 RX2_GAIN_Q		:16;//Регистр установки “точного” комплексного коэффициента усиления (Q компонента)
	u16 RX2_NCO_PHASE	:16;//Регистр начальной фазы гетеродина
	u16 RX2_NCO_FRQL	:16;//Регистр частоты гетеродина, младшие 16 разрядов
	u16 RX2_NCO_FRQH	:16;//Регистр частоты гетеродина, старшие 16 разрядов
	u16 RX2_CF_DFIR1[64];//Коэффициенты первого DFIR фильтра-дециматора
	u16 RX2_CF_DFIR2[64];//Коэффициенты второго DFIR фильтра-дециматора

	u16 RX3				:16;//Регистры второго канала приема
	u16 RX3_OVF			:16;//Регистр флагов переполнения, сбрасывается при чтении
	u16 RX3_LCFG		:16;//Регистр конфигурации отдельного канала
	u16 RX3_DCIC2		:16;//Регистр конфигурации первой ступени CIC-дециматоров
	u16 RX3_DCICN		:16;//Регистр конфигурации второй ступени CIC-дециматоров
	u16 RX3_DFIR1_CFG1	:16;//Регистр конфигурации 1 первого КИХ-фильтра-дециматора
	u16 RX3_DFIR1_CFG2 	:16;//Регистр конфигурации 2 первого КИХ-фильтра-дециматора
	u16 RX3_DFIR2_CFG1	:16;//Регистр конфигурации 1 второго КИХ-фильтра-дециматора
	u16 RX3_DFIR2_CFG2 	:16;//Регистр конфигурации 2 второго КИХ-фильтра-дециматора
	u16 RX3_GAIN_I		:16;//Регистр установки “точного” комплексного коэффициента усиления (I компонента)
	u16 RX3_GAIN_Q		:16;//Регистр установки “точного” комплексного коэффициента усиления (Q компонента)
	u16 RX3_NCO_PHASE	:16;//Регистр начальной фазы гетеродина
	u16 RX3_NCO_FRQL	:16;//Регистр частоты гетеродина, младшие 16 разрядов
	u16 RX3_NCO_FRQH	:16;//Регистр частоты гетеродина, старшие 16 разрядов
	u16 RX3_CF_DFIR1[64];//Коэффициенты первого DFIR фильтра-дециматора
	u16 RX3_CF_DFIR2[64];//Коэффициенты второго DFIR фильтра-дециматора

	u16 RX4				:16;//Регистры второго канала приема
	u16 RX4_OVF			:16;//Регистр флагов переполнения, сбрасывается при чтении
	u16 RX4_LCFG		:16;//Регистр конфигурации отдельного канала
	u16 RX4_DCIC2		:16;//Регистр конфигурации первой ступени CIC-дециматоров
	u16 RX4_DCICN		:16;//Регистр конфигурации второй ступени CIC-дециматоров
	u16 RX4_DFIR1_CFG1	:16;//Регистр конфигурации 1 первого КИХ-фильтра-дециматора
	u16 RX4_DFIR1_CFG2 	:16;//Регистр конфигурации 2 первого КИХ-фильтра-дециматора
	u16 RX4_DFIR2_CFG1	:16;//Регистр конфигурации 1 второго КИХ-фильтра-дециматора
	u16 RX4_DFIR2_CFG2 	:16;//Регистр конфигурации 2 второго КИХ-фильтра-дециматора
	u16 RX4_GAIN_I		:16;//Регистр установки “точного” комплексного коэффициента усиления (I компонента)
	u16 RX4_GAIN_Q		:16;//Регистр установки “точного” комплексного коэффициента усиления (Q компонента)
	u16 RX4_NCO_PHASE	:16;//Регистр начальной фазы гетеродина
	u16 RX4_NCO_FRQL	:16;//Регистр частоты гетеродина, младшие 16 разрядов
	u16 RX4_NCO_FRQH	:16;//Регистр частоты гетеродина, старшие 16 разрядов
	u16 RX4_CF_DFIR1[64];//Коэффициенты первого DFIR фильтра-дециматора
	u16 RX4_CF_DFIR2[64];//Коэффициенты второго DFIR фильтра-дециматора


} reg_1288;

 reg_1288 DSP;


void INIT_REG_DSP (reg_1288 *dsp)
{
 //dsp->output_delayab			  =0;
 dsp->SWRST = 0x0078;
 dsp->DEVID = 0x0000;
 dsp->INT   = 0x0000;
 dsp->INTE	= 0x0000;
 dsp->INTR  = 0x0000;

 dsp->SYNC  = 0x0000;
 dsp->SYNC  = (1<<15) // «1»включается «Master» синхронизации
			 |(0<<10) // Зарезервировано
			 |(1<<9 ) // Запись логической «1» вызывает сброс FIFO.
			 |(1<<8 ) // Запись «1» запускает процесс очистки трактов данных, включая сброс FIFO.
			 |(0<<3 ) // Зарезервировано
			 |(1<<2 ) // Синхронизация установки «точного» коэффициента усиления
			 |(1<<1 ) // Бит синхронной установки частоты и фазы гетеродинов всех каналов
			 |(1<<0 );// Запись «1» переводит 1288ХК1Т в состояние обработки сигнала и осуществляет синхронизацию старта нескольких микросхем.

  dsp->ADC_CFG = 0x0000;
  dsp->ADC_CFG = (0<<15)
				|(1<<14)  //enc_mode  | «1» соответствует выборке входных отсчетов по фронту ENCODE.Используется только в том случае, если сигнал ENCODE–входной (enc_dir =0 )
				|(1<<13)  //enc_phase |«0» соответствует тому, что активный уровень – высокий или же активный фронт – возрастающий;
				|(0<<12)  //enc_dir   |Управление источником сигнала ENCODE:«0» соответствует тому, что сигнал ENCODE является входным сигналом;
				|(0<<8 )  //enc_div   |Коэффициент деления выходной тактовой частоты ENCODE:0 - 1/1
				|(0<<7 )  //Тестовый бит. Для корректной работы должен быть установлен в 0
				|(0<<4 )  //Зарезервировано
				|(0<<0 ); //Тестовый бит. Для корректной работы должен быть установлен в 0

   dsp->RX_CFG = 0x0000;
   dsp->RX_CFG = (1<<15) //wr_all  | «1» соответствует одновременной записи во все каналы
				|(0<<11) //pf_mode | Зарезервировано
				|(0<<9 ) //out_fmt | Режимы работы PF:- «0» соответствует тому, что активный - высокий уровень;
				|(1<<8 ) //Mode    | Формат выходных данных каналов приема:«0» соответствует формату 16+16;
				|(0<<6 ) //in_type | - «01» - двухканальный режим (объединяются каналы 1+2 и 3+4);
				|(0<<3 ) //        | Промежуточная частота, действительные данные
				|(0<<2 ) //        | Зарезервировано
				|(1<<0 );//in_fmt  | Формат входных данных каналов приема:Прямой

	dsp->RX_FIFO_THRESH = 0x7fff;//содержит шестнадцатибитовый порог заполненности FIFO каналов приема.

	dsp->RX_LINK = 0x0000;
	dsp->RX_LINK = (0<<6 ) //Зарезервировано
				  |(3<<4 ) //Делитель тактовой частоты линк-порта:PCLK/8
				  |(0<<3 ) //Зарезервировано
				  |(0<<1 ) //Делитель тактовой частоты линк-порта:8-битовый SHARС
				  |(1<<0 );//«1» соответствует тому, что линк - порт включен

	dsp-> RX1_LCFG = 0x0000;
	dsp-> RX1_LCFG = (1<<15)
					|(0<<14) //«1» приводит к включению дизеринга гетеродина
					|(0<<10) //Зарезервировано
					|(0<<8 ) //Выбор источника сигнала. Для комплексного сигнала:- выбор «src» соответствует компоненте I;
					|(0<<5 ) //Зарезервировано
					|(0<<4 ) //Разрешение прерывания от перегрузки ограничителя разрядности комплексного умножителя «z»
					|(0<<3 ) //Разрешение прерывания от перегрузки ограничителя разрядности второго каскада FIR - децимации
					|(0<<2 ) //Разрешение прерывания от перегрузки ограничителя разрядности первого каскада FIR - децимации
					|(0<<1 ) //Разрешение прерывания от перегрузки ограничителя разрядности второго каскада CIC - децимации
					|(0<<0 );//Разрешение прерывания от перегрузки ограничителя разрядности первого каскада CIC - децимации

	dsp-> RX2_LCFG = 0x0000;
	dsp-> RX2_LCFG = (1<<15)
					|(0<<14) //«1» приводит к включению дизеринга гетеродина
					|(0<<10) //Зарезервировано
					|(0<<8 ) //Выбор источника сигнала. Для комплексного сигнала:- выбор «src» соответствует компоненте I;
					|(0<<5 ) //Зарезервировано
					|(0<<4 ) //Разрешение прерывания от перегрузки ограничителя разрядности комплексного умножителя «z»
					|(0<<3 ) //Разрешение прерывания от перегрузки ограничителя разрядности второго каскада FIR - децимации
					|(0<<2 ) //Разрешение прерывания от перегрузки ограничителя разрядности первого каскада FIR - децимации
					|(0<<1 ) //Разрешение прерывания от перегрузки ограничителя разрядности второго каскада CIC - децимации
					|(0<<0 );//Разрешение прерывания от перегрузки ограничителя разрядности первого каскада CIC - децимации

	dsp-> RX3_LCFG = 0x0000;
	dsp-> RX3_LCFG = (1<<15)
					|(0<<14) //«1» приводит к включению дизеринга гетеродина
					|(0<<10) //Зарезервировано
					|(0<<8 ) //Выбор источника сигнала. Для комплексного сигнала:- выбор «src» соответствует компоненте I;
					|(0<<5 ) //Зарезервировано
					|(0<<4 ) //Разрешение прерывания от перегрузки ограничителя разрядности комплексного умножителя «z»
					|(0<<3 ) //Разрешение прерывания от перегрузки ограничителя разрядности второго каскада FIR - децимации
					|(0<<2 ) //Разрешение прерывания от перегрузки ограничителя разрядности первого каскада FIR - децимации
					|(0<<1 ) //Разрешение прерывания от перегрузки ограничителя разрядности второго каскада CIC - децимации
					|(0<<0 );//Разрешение прерывания от перегрузки ограничителя разрядности первого каскада CIC - децимации

	dsp-> RX4_LCFG = 0x0000;
	dsp-> RX4_LCFG = (1<<15)
					|(0<<14) //«1» приводит к включению дизеринга гетеродина
					|(0<<10) //Зарезервировано
					|(0<<8 ) //Выбор источника сигнала. Для комплексного сигнала:- выбор «src» соответствует компоненте I;
					|(0<<5 ) //Зарезервировано
					|(0<<4 ) //Разрешение прерывания от перегрузки ограничителя разрядности комплексного умножителя «z»
					|(0<<3 ) //Разрешение прерывания от перегрузки ограничителя разрядности второго каскада FIR - децимации
					|(0<<2 ) //Разрешение прерывания от перегрузки ограничителя разрядности первого каскада FIR - децимации
					|(0<<1 ) //Разрешение прерывания от перегрузки ограничителя разрядности второго каскада CIC - децимации
					|(0<<0 );//Разрешение прерывания от перегрузки ограничителя разрядности первого каскада CIC - децимации

	dsp-> RX1_DCIC2 = 0x0000;
	dsp-> RX1_DCIC2 = (1<<15)
					 |(0<<8 )  //Коэффициент децимации первой ступени CIC - дециматора:M = dr + 1
					 |(0<<4 )  //Зарезервировано
					 |(0x0f ); //Регулировка уровня выходного сигнала первой ступени CIC - дециматора.

	dsp-> RX2_DCIC2 = 0x0000;
	dsp-> RX2_DCIC2 = (1<<15)
					 |(0<<8 )  //Коэффициент децимации первой ступени CIC - дециматора:M = dr + 1
					 |(0<<4 )  //Зарезервировано
					 |(0x0f ); //Регулировка уровня выходного сигнала первой ступени CIC - дециматора.

	dsp-> RX3_DCIC2 = 0x0000;
	dsp-> RX3_DCIC2 = (1<<15)
					 |(0<<8 )  //Коэффициент децимации первой ступени CIC - дециматора:M = dr + 1
					 |(0<<4 )  //Зарезервировано
					 |(0x0f ); //Регулировка уровня выходного сигнала первой ступени CIC - дециматора.

	dsp-> RX4_DCIC2 = 0x0000;
	dsp-> RX4_DCIC2 = (1<<15)
					 |(0<<8 )  //Коэффициент децимации первой ступени CIC - дециматора:M = dr + 1
					 |(0<<4 )  //Зарезервировано
					 |(0x0f ); //Регулировка уровня выходного сигнала первой ступени CIC - дециматора.

	dsp-> RX1_DCICN = 0x0000;
	dsp-> RX1_DCICN = (3<<14) //Биты конфигурации 2-й ступени CIC–дециматора:- «112» - 2-й каскад децимации включен в режиме CIC6
					 |(1<<8 ) //Коэффициент децимации 2-й ступени CIC-дециматора:M = dr + 1
					 |(0<<5 ) //Зарезервировано
					 |(0<<4 ) //Выбор диапазона регулировки уровня выходного сигнала 2-й ступени CIC-дециматора
					 |(0x0f );//Регулировка уровня выходного сигнала 2-й ступени CIC-дециматора:- если scl_mx = 1, то коэффициент передачи CIC–дециматора

	dsp-> RX2_DCICN = 0x0000;
	dsp-> RX2_DCICN = (3<<14) //Биты конфигурации 2-й ступени CIC–дециматора:- «112» - 2-й каскад децимации включен в режиме CIC6
					 |(1<<8 ) //Коэффициент децимации 2-й ступени CIC-дециматора:M = dr + 1
					 |(0<<5 ) //Зарезервировано
					 |(0<<4 ) //Выбор диапазона регулировки уровня выходного сигнала 2-й ступени CIC-дециматора
					 |(0x0f );//Регулировка уровня выходного сигнала 2-й ступени CIC-дециматора:- если scl_mx = 1, то коэффициент передачи CIC–дециматора

	dsp-> RX3_DCICN = 0x0000;
	dsp-> RX3_DCICN = (3<<14) //Биты конфигурации 2-й ступени CIC–дециматора:- «112» - 2-й каскад децимации включен в режиме CIC6
					 |(1<<8 ) //Коэффициент децимации 2-й ступени CIC-дециматора:M = dr + 1
					 |(0<<5 ) //Зарезервировано
					 |(0<<4 ) //Выбор диапазона регулировки уровня выходного сигнала 2-й ступени CIC-дециматора
					 |(0x0f );//Регулировка уровня выходного сигнала 2-й ступени CIC-дециматора:- если scl_mx = 1, то коэффициент передачи CIC–дециматора

	dsp-> RX4_DCICN = 0x0000;
	dsp-> RX4_DCICN = (3<<14) //Биты конфигурации 2-й ступени CIC–дециматора:- «112» - 2-й каскад децимации включен в режиме CIC6
					 |(1<<8 ) //Коэффициент децимации 2-й ступени CIC-дециматора:M = dr + 1
					 |(0<<5 ) //Зарезервировано
					 |(0<<4 ) //Выбор диапазона регулировки уровня выходного сигнала 2-й ступени CIC-дециматора
					 |(0x0f );//Регулировка уровня выходного сигнала 2-й ступени CIC-дециматора:- если scl_mx = 1, то коэффициент передачи CIC–дециматора

	dsp->RX1_DFIR1_CFG1 = 0x0000;
	dsp->RX1_DFIR1_CFG1 = (0 <<15) //Зарезервировано
						 |(0 <<14) //Симметричность:- «0» - симметричный;
						 |(10<<8 ) //Установка порядка фильтра: Ntap = order + 1
						 |(1 <<4 ) //Установка задержки синхронизации (0:15)
						 |(0x0f  );//Установка коэффициента децимации: M = dr + 1

	dsp->RX2_DFIR1_CFG1 = 0x0000;
	dsp->RX2_DFIR1_CFG1 = (0 <<15) //Зарезервировано
						 |(0 <<14) //Симметричность:- «0» - симметричный;
						 |(10<<8 ) //Установка порядка фильтра: Ntap = order + 1
						 |(1 <<4 ) //Установка задержки синхронизации (0:15)
						 |(0x0f  );//Установка коэффициента децимации: M = dr + 1

	dsp->RX3_DFIR1_CFG1 = 0x0000;
	dsp->RX3_DFIR1_CFG1 = (0 <<15) //Зарезервировано
						 |(0 <<14) //Симметричность:- «0» - симметричный;
						 |(10<<8 ) //Установка порядка фильтра: Ntap = order + 1
						 |(1 <<4 ) //Установка задержки синхронизации (0:15)
						 |(0x0f  );//Установка коэффициента децимации: M = dr + 1

	dsp->RX4_DFIR1_CFG1 = 0x0000;
	dsp->RX4_DFIR1_CFG1 = (0 <<15) //Зарезервировано
						 |(0 <<14) //Симметричность:- «0» - симметричный;
						 |(10<<8 ) //Установка порядка фильтра: Ntap = order + 1
						 |(1 <<4 ) //Установка задержки синхронизации (0:15)
						 |(0x0f  );//Установка коэффициента децимации: M = dr + 1

	dsp->RX1_DFIR1_CFG2 = 0x0000;
	dsp->RX1_DFIR1_CFG2 = (0<<4 ) //Зарезервировано
						  |(0x00f);//Регулировка уровня выходного сигнала DFIR1.Коэффициент усиления на выходе DFIR1 равен 2scl-21

	dsp->RX2_DFIR1_CFG2 = 0x0000;
	dsp->RX2_DFIR1_CFG2 = (0<<4 ) //Зарезервировано
						  |(0x00f);//Регулировка уровня выходного сигнала DFIR1.Коэффициент усиления на выходе DFIR1 равен 2scl-21

	dsp->RX3_DFIR1_CFG2 = 0x0000;
	dsp->RX3_DFIR1_CFG2 = (0<<4 ) //Зарезервировано
						  |(0x00f);//Регулировка уровня выходного сигнала DFIR1.Коэффициент усиления на выходе DFIR1 равен 2scl-21

	dsp->RX4_DFIR1_CFG2 = 0x0000;
	dsp->RX4_DFIR1_CFG2 = (0<<4 ) //Зарезервировано
						  |(0x00f);//Регулировка уровня выходного сигнала DFIR1.Коэффициент усиления на выходе DFIR1 равен 2scl-21


	dsp->RX1_DFIR2_CFG1 = 0x0000;
	dsp->RX1_DFIR2_CFG1 = (0 <<15) //Зарезервировано
						 |(0 <<14) //Симметричность:- «0» - симметричный;
						 |(10<<8 ) //Установка порядка фильтра: Ntap = order + 1
						 |(1 <<4 ) //Установка задержки синхронизации (0:15)
						 |(0x0f  );//Установка коэффициента децимации: M = dr + 1

	dsp->RX2_DFIR2_CFG1 = 0x0000;
	dsp->RX2_DFIR2_CFG1 = (0 <<15) //Зарезервировано
						 |(0 <<14) //Симметричность:- «0» - симметричный;
						 |(10<<8 ) //Установка порядка фильтра: Ntap = order + 1
						 |(1 <<4 ) //Установка задержки синхронизации (0:15)
						 |(0x0f  );//Установка коэффициента децимации: M = dr + 1

	dsp->RX3_DFIR2_CFG1 = 0x0000;
	dsp->RX3_DFIR2_CFG1 = (0 <<15) //Зарезервировано
						 |(0 <<14) //Симметричность:- «0» - симметричный;
						 |(10<<8 ) //Установка порядка фильтра: Ntap = order + 1
						 |(1 <<4 ) //Установка задержки синхронизации (0:15)
						 |(0x0f  );//Установка коэффициента децимации: M = dr + 1

	dsp->RX4_DFIR2_CFG1 = 0x0000;
	dsp->RX4_DFIR2_CFG1 = (0 <<15) //Зарезервировано
						 |(0 <<14) //Симметричность:- «0» - симметричный;
						 |(10<<8 ) //Установка порядка фильтра: Ntap = order + 1
						 |(1 <<4 ) //Установка задержки синхронизации (0:15)
						 |(0x0f  );//Установка коэффициента децимации: M = dr + 1

	dsp->RX1_DFIR2_CFG2 = 0x0000;
	dsp->RX1_DFIR2_CFG2 = (0 <<4) //Зарезервировано
						 |(0x0f );//Регулировка уровня выходного сигнала DFIR2.Коэффициент усиления на выходе DFIR2 равен 2scl-21

	dsp->RX2_DFIR2_CFG2 = 0x0000;
	dsp->RX2_DFIR2_CFG2 = (0 <<4) //Зарезервировано
						 |(0x0f );//Регулировка уровня выходного сигнала DFIR2.Коэффициент усиления на выходе DFIR2 равен 2scl-21

	dsp->RX3_DFIR2_CFG2 = 0x0000;
	dsp->RX3_DFIR2_CFG2 = (0 <<4) //Зарезервировано
						 |(0x0f );//Регулировка уровня выходного сигнала DFIR2.Коэффициент усиления на выходе DFIR2 равен 2scl-21

	dsp->RX4_DFIR2_CFG2 = 0x0000;
	dsp->RX4_DFIR2_CFG2 = (0 <<4) //Зарезервировано
						 |(0x0f );//Регулировка уровня выходного сигнала DFIR2.Коэффициент усиления на выходе DFIR2 равен 2scl-21

//-------------Для обновления внутренних значений необходимо записать «1» в бит SYNC_sync_nco.	----------------------------

	dsp->RX1_NCO_PHASE = 0x0000; //регистр установки начальной фазы
	dsp->RX2_NCO_PHASE = 0x0000; //регистр установки начальной фазы
	dsp->RX3_NCO_PHASE = 0x0000; //регистр установки начальной фазы
	dsp->RX4_NCO_PHASE = 0x0000; //регистр установки начальной фазы

	dsp->RX1_NCO_FRQL  = 0x0000;//75 MHz
	dsp->RX1_NCO_FRQH  = 0xc000;

	dsp->RX2_NCO_FRQL  = 0x0000;//75 MHz
	dsp->RX2_NCO_FRQH  = 0xc000;

	dsp->RX3_NCO_FRQL  = 0x0000;//75 MHz
	dsp->RX3_NCO_FRQH  = 0xc000;

	dsp->RX4_NCO_FRQL  = 0x0000;//75 MHz
	dsp->RX4_NCO_FRQH  = 0xc000;

//-------------Для обновления внутренних значений необходимо записать «1» в бит SYNC_sync_gain.	--------------------------

	dsp->RX1_GAIN_I = 0xffff;//регистры установки комплексного коэффициента усиления (GAIN_I+j*GAIN_Q) Используемая кодировка – дополнение до двух
	dsp->RX1_GAIN_Q = 0xffff;

	dsp->RX2_GAIN_I = 0xffff;//регистры установки комплексного коэффициента усиления (GAIN_I+j*GAIN_Q) Используемая кодировка – дополнение до двух
	dsp->RX2_GAIN_Q = 0xffff;

	dsp->RX3_GAIN_I = 0xffff;//регистры установки комплексного коэффициента усиления (GAIN_I+j*GAIN_Q) Используемая кодировка – дополнение до двух
	dsp->RX3_GAIN_Q = 0xffff;

	dsp->RX4_GAIN_I = 0xffff;//регистры установки комплексного коэффициента усиления (GAIN_I+j*GAIN_Q) Используемая кодировка – дополнение до двух
	dsp->RX4_GAIN_Q = 0xffff;

//-----При четном порядке фильтра коэффициенты записываются как есть. При нечетном
//		порядке фильтра записываемое значение центрального коэффициента должно быть равно
//			половине значения центрального коэффициента.
//				Нечетные регистры зарезервированы для расширения разрядности коэффициентов.

	dsp->RX1_CF_DFIR1[0]  = 0x0000;//Коэффициенты отводов 1 и ORDER
	dsp->RX1_CF_DFIR1[1]  = 0x0000;//Зарезервировано
	//*
	//*
	dsp->RX1_CF_DFIR1[62] = 0x0000;//Коэффициенты отводов 32 и ORDER-31
	dsp->RX1_CF_DFIR1[63] = 0x0000;//Зарезервировано

	dsp->RX2_CF_DFIR1[0]  = 0x0000;//Коэффициенты отводов 1 и ORDER
	dsp->RX2_CF_DFIR1[1]  = 0x0000;//Зарезервировано
	//*
	//*
	dsp->RX2_CF_DFIR1[62] = 0x0000;//Коэффициенты отводов 32 и ORDER-31
	dsp->RX2_CF_DFIR1[63] = 0x0000;//Зарезервировано

	dsp->RX3_CF_DFIR1[0]  = 0x0000;//Коэффициенты отводов 1 и ORDER
	dsp->RX3_CF_DFIR1[1]  = 0x0000;//Зарезервировано
	//*
	//*
	dsp->RX3_CF_DFIR1[62] = 0x0000;//Коэффициенты отводов 32 и ORDER-31
	dsp->RX3_CF_DFIR1[63] = 0x0000;//Зарезервировано

	dsp->RX4_CF_DFIR1[0]  = 0x0000;//Коэффициенты отводов 1 и ORDER
	dsp->RX4_CF_DFIR1[1]  = 0x0000;//Зарезервировано
	//*
	//*
	dsp->RX4_CF_DFIR1[62] = 0x0000;//Коэффициенты отводов 32 и ORDER-31
	dsp->RX4_CF_DFIR1[63] = 0x0000;//Зарезервировано


//-----При четном порядке фильтра коэффициенты записываются как есть. При нечетном
//		порядке фильтра записываемое значение центрального коэффициента должно быть равно
//			половине значения центрального коэффициента.
//				Нечетные регистры зарезервированы для расширения разрядности коэффициентов.

	dsp->RX1_CF_DFIR2[0]  = 0x0000;//Коэффициенты отводов 1 и ORDER
	dsp->RX1_CF_DFIR2[1]  = 0x0000;//Зарезервировано
	//*
	//*
	dsp->RX1_CF_DFIR2[62] = 0x0000;//Коэффициенты отводов 32 и ORDER-31
	dsp->RX1_CF_DFIR2[63] = 0x0000;//Зарезервировано

	dsp->RX2_CF_DFIR2[0]  = 0x0000;//Коэффициенты отводов 1 и ORDER
	dsp->RX2_CF_DFIR2[1]  = 0x0000;//Зарезервировано
	//*
	//*
	dsp->RX2_CF_DFIR2[62] = 0x0000;//Коэффициенты отводов 32 и ORDER-31
	dsp->RX2_CF_DFIR2[63] = 0x0000;//Зарезервировано

	dsp->RX3_CF_DFIR2[0]  = 0x0000;//Коэффициенты отводов 1 и ORDER
	dsp->RX3_CF_DFIR2[1]  = 0x0000;//Зарезервировано
	//*
	//*
	dsp->RX3_CF_DFIR2[62] = 0x0000;//Коэффициенты отводов 32 и ORDER-31
	dsp->RX3_CF_DFIR2[63] = 0x0000;//Зарезервировано

	dsp->RX4_CF_DFIR2[0]  = 0x0000;//Коэффициенты отводов 1 и ORDER
	dsp->RX4_CF_DFIR2[1]  = 0x0000;//Зарезервировано
	//*
	//*
	dsp->RX4_CF_DFIR2[62] = 0x0000;//Коэффициенты отводов 32 и ORDER-31
	dsp->RX4_CF_DFIR2[63] = 0x0000;//Зарезервировано


}

void defrag_REG_DSP (reg_1288 *dsp)
{

}

//---------------------------------------------------------------------


void report_high(const char * str)
{
	Transf(str);
	Transf("\r\n");
}

volatile struct GIGASPWR_REGS_BASE * REGS = (volatile struct GIGASPWR_REGS_BASE *) 0xB82FA000;
volatile struct GIGASPWR_PMA_TEST_CSR_BASE * PMA_TEST_CSR = (volatile struct GIGASPWR_PMA_TEST_CSR_BASE *) 0xB82FA200;
volatile unsigned int * ROUTING_TABLE = (volatile unsigned int *)0xB82FA400;


void unmask_irq(unsigned int mask) {
  REGS->RISC_IRQ_MASK &= ~mask;
}

void form_routing_table(bool del_header) {
  unsigned int i;
  for ( i=0; i < 16; i++)
    ROUTING_TABLE[i] = (((unsigned int)1 << i) & 0x7f) | 0x080 | ((del_header & 1) << 8);
}

void gspwr_form_adg() {
  report_high("form adg");
  int i;
  for (i = 0; i < 6; i++)
    REGS->ADG[i] = ((unsigned int)2 << i) ;
}

void set_transmit_speed(unsigned int port, int speed, bool pll_en) {
  unsigned int tx_speed;
  switch (port) {
    case port_spw0:
    case port_spw1:
      if (speed == 0)
            speed = GET_GIGASPWR_SPW_TX_SPEED_TX_SPEED(REGS->SPW_TX_SPEED[port]);
      else if (speed >= 5)
            speed = speed / 5;
      if (pll_en)
            speed |= 0x300;
      else
            speed &= ~0x300;
      tx_speed = REGS->SPW_TX_SPEED[port];
          tx_speed = SET_GIGASPWR_SPW_TX_SPEED_TX_SPEED(tx_speed, speed);
      tx_speed = SET_GIGASPWR_SPW_TX_SPEED_TX_SPEED10(tx_speed, speed);
      REGS->SPW_TX_SPEED[port] = tx_speed;
      break;
    case port_gigaspw0:
    case port_gigaspw1:
    case port_gigaspw2:
    case port_gigaspw3:
      if (speed > 0)
        REGS->GIGA_SPW_PMA_MODE[port - port_gigaspw0] = SET_GIGASPWR_GIGA_SPW_PMA_MODE_PMA_TX_SPEED(REGS->GIGA_SPW_PMA_MODE[port - port_gigaspw0], speed);

              tx_speed = REGS->GIGA_SPW_PMA_MODE[port - port_gigaspw0];
              tx_speed = SET_GIGASPWR_GIGA_SPW_PMA_MODE_CDR_MODE(tx_speed, 1);
//               tx_speed = SET_GIGASPWR_GIGA_SPW_PMA_MODE_LB_EN_RX(tx_speed, 1);
//               tx_speed = SET_GIGASPWR_GIGA_SPW_PMA_MODE_LB_EN_TX(tx_speed, 1);
              REGS->GIGA_SPW_PMA_MODE[port - port_gigaspw0] = tx_speed;

      tx_speed = REGS->GIGA_SPW_TX_SPEED[port - port_gigaspw0];
      if (speed < gigasw_speed_312_mhz)
        tx_speed = SET_GIGASPWR_GIGA_SPW_TX_SPEED_KOEFF_COMMA(tx_speed, 1);
      else
        tx_speed = SET_GIGASPWR_GIGA_SPW_TX_SPEED_KOEFF_COMMA(tx_speed, 8);

      tx_speed = SET_GIGASPWR_GIGA_SPW_TX_SPEED_DISCONNECT_COUNTER(tx_speed, 0xf);

      tx_speed = SET_GIGASPWR_GIGA_SPW_TX_SPEED_PWDN_TX(tx_speed, pll_en);
      tx_speed = SET_GIGASPWR_GIGA_SPW_TX_SPEED_PWDN_RX(tx_speed, pll_en);
      tx_speed = SET_GIGASPWR_GIGA_SPW_TX_SPEED_COMMAEN(tx_speed, pll_en);
      tx_speed = SET_GIGASPWR_GIGA_SPW_TX_SPEED_COMPARE_EN(tx_speed, pll_en);
      REGS->GIGA_SPW_TX_SPEED[port - port_gigaspw0] = tx_speed;
      break;
  }
}

//void GIGASPWR_cl::set_recive_speed(unsigned int port, int speed) {
void set_recive_speed(unsigned int port, int speed) {
  switch (port) {
    case port_gigaspw0:
    case port_gigaspw1:
    case port_gigaspw2:
    case port_gigaspw3:
      if (speed > 0)
        REGS->GIGA_SPW_PMA_MODE[port - port_gigaspw0] = SET_GIGASPWR_GIGA_SPW_PMA_MODE_PMA_RX_SPEED(REGS->GIGA_SPW_PMA_MODE[port - port_gigaspw0], speed);
      break;
  }
}

//void GIGASPWR_cl::make_desc(unsigned int *desc_src, int data_len, int route) {
void make_desc(unsigned int *desc_src, int data_len, int route) {
  desc_src[0] = 0xA0000000 + (data_len & 0x0fffffff);
  desc_src[1] = route;
}

//void GIGASPWR_cl::set_dma_enabled(bool dma_en) {
void set_dma_enabled(bool dma_en) {
  REGS->MODE_R = SET_GIGASPWR_MODE_R_DMA_ENABLED(REGS->MODE_R, dma_en);
}

//void GIGASPWR_cl::set_work_enabled(bool work_en) {
void set_work_enabled(bool work_en) {
  REGS->MODE_R = SET_GIGASPWR_MODE_R_MAIN_KOEFF10(REGS->MODE_R, 0xb);
  REGS->MODE_R = SET_GIGASPWR_MODE_R_GIGASPWR_WE(REGS->MODE_R, work_en);
}

//void GIGASPWR_cl::start_connect(unsigned int port) {
void start_connect(unsigned int port) {
  unsigned int spw_mode;

  if (port > port_max_numb)
    return;

  spw_mode = REGS->SPW_MODE[port];
  spw_mode = SET_GIGASPWR_SPW_MODE_LINKSTART(spw_mode, 1);
//   spw_mode = SET_GIGASPWR_SPW_MODE_AUTO_SPEED_MODE(spw_mode, 1);
  spw_mode = SET_GIGASPWR_SPW_MODE_LINKDISABLED(spw_mode, 0);
  spw_mode = SET_GIGASPWR_SPW_MODE_BDS_RESET(spw_mode, 1);
  spw_mode = SET_GIGASPWR_SPW_MODE_AUTOSTART(spw_mode, 1);
  spw_mode = SET_GIGASPWR_SPW_MODE_D_INT_ACK_REGIMES(spw_mode, 0);
  spw_mode = SET_GIGASPWR_SPW_MODE_INT_CODES(spw_mode, 0);
  spw_mode = SET_GIGASPWR_SPW_MODE_ACK_CODES(spw_mode, 0);

  REGS->SPW_MODE[port] = spw_mode;
}

//unsigned int GIGASPWR_cl::get_status(unsigned int port, bool print) {
unsigned int get_status(unsigned int port, bool print) {
  unsigned int ds_state;

  if (port > port_max_numb)
    return 0xFFFFFFFF;

  ds_state = GET_GIGASPWR_SPW_STATUS_BDS_STATE(REGS->SPW_STATUS[port]);

  if (print) {
    switch (ds_state) {
      case link_status_err_reset:
        report_high("Error Reset");
        break;
      case link_status_err_wait:
        report_high("Error Wait");
        break;
      case link_status_ready:
        report_high("Ready");
        break;
      case link_status_started:
        report_high("Started");
        break;
      case link_status_connecting:
        report_high("Connecting");
        break;
      case link_status_run:
        report_high("Run");
        break;
      default:
        report_high("Unknown Status");
    }
  }
  return ds_state;
}


//int GIGASPWR_cl::wait_link_status(unsigned int port, unsigned int status, unsigned int timeout) {
int wait_link_status(unsigned int port, unsigned int status, unsigned int timeout) {
  unsigned int t = 0;
  //while (this->get_status(port, false) != status) {
  while (get_status(port, false) != status) {
    if ((++t >= timeout) && (timeout != 0)) {
      report_high("timeout reached");
      return 1;
    }
  }
  return 0;
}

//unsigned int GIGASPWR_cl::get_rx_speed(unsigned int port) {
unsigned int get_rx_speed(unsigned int port) {
  return REGS->SPW_RX_SPEED[port];
}

//,==== SpW_bridge_mcom02 - Мост для ретрансляции данных на портах Space Wire от другого устройства (mcom02) ====
unsigned int check_SpW_link_status_run(GIGASPWR_cl* gigaspwr, unsigned int SpW_port_n) {
  //unsigned int cur_link_status = gigaspwr->get_status(SpW_port_n, false);
  unsigned int cur_link_status = get_status(SpW_port_n, false);
  if (cur_link_status != link_status_run) {
    //report_error("Error link_status_run [SpW_port_n / cur_link_status]:");
    //print_val(SpW_port_n);
    //print_val(cur_link_status);
    return 1;
  }
  return 0;
}

void turn_off(unsigned int port){
  unsigned int spw_mode;

  if (port > port_max_numb)
    return;

  spw_mode = REGS->SPW_MODE[port];
  spw_mode = SET_GIGASPWR_SPW_MODE_LINKSTART(spw_mode, 0);
  spw_mode = SET_GIGASPWR_SPW_MODE_LINKDISABLED(spw_mode, 1);
  spw_mode = SET_GIGASPWR_SPW_MODE_BDS_RESET(spw_mode, 1);
  REGS->SPW_MODE[port] = spw_mode;

  spw_mode = REGS->STATE_R;
  spw_mode = SET_GIGASPWR_STATE_R_PORT_CONNECTED(spw_mode, 0x3f);
  spw_mode = SET_GIGASPWR_STATE_R_PORT_ERRORED(spw_mode, 0x3f);
  REGS->STATE_R = spw_mode;

  set_transmit_speed(port, 0, false);
  set_dma_enabled(false);
  set_work_enabled(false);
}


void FillArray(unsigned int *array, unsigned int len, int first) {
        unsigned int i;
        array[0] = 0; // Always config
        for (i=1;i<len;i++) {
                array[i] = i-1+first;
        }
}

int VerifyArray(unsigned int *array, unsigned int len, int first) {
        unsigned int i;
        if (array[0] != 0) return 0;
        for (i=1;i<len;i++) {
                if(array[i] != i-1+first) return 0;
        }
        return 1;
}

void timer_hnlr(int a)
{
  Flag_Timeout = 1;
  unsigned int param= 0;
  asm volatile ("mtc0 %0, $11" : : "r"(param));
  asm volatile ("nop");
//asm volatile ("break 0x0, 0x1");
  asm volatile ("nop");
}

void dc_hnlr(int a)
{
  Flag_Disconnect = 1;
  asm volatile ("nop");
  asm volatile("break 0x0, 0x1");
  asm volatile ("nop");
}

//---------------------------------

/* reverse:  переворачиваем строку s на месте */
 void reverse(char s[])
 {
     int i, j;
     char c;

     for (i = 0, j = strlen(s)-1; i<j; i++, j--) {
         c = s[i];
         s[i] = s[j];
         s[j] = c;
     }
 }

 /* itoa:  конвертируем n в символы в s */
 void itoa(int n, char s[])
 {
     int i, sign;

     if ((sign = n) < 0)  /* записываем знак */
         n = -n;          /* делаем n положительным числом */
     i = 0;
     do {       /* генерируем цифры в обратном порядке */
         s[i++] = n % 10 + '0';   /* берем следующую цифру */
     } while ((n /= 10) > 0);     /* удаляем */
     if (sign < 0)
         s[i++] = '-';
     s[i] = '\0';
     reverse(s);
 }

 void itox(unsigned int i, char *s)
{
    unsigned char n;

    s += 4;
    *s = '\0';

    for (n = 4; n != 0; --n) {
        *--s = "0123456789ABCDEF"[i & 0x0F];
        i >>= 4;
    }
}



// Инициализация UART
// варьируется только скорость обмена
// остальные параметры не задаются
// длина слова - 8 бит
// стоп-бит - 1
// четность не контролируется
// управление потоком данных отсутствует
// BaudRate - скорость обмена
// Freq - частота процессора
void UART1_conf(int BaudRate, int Frq) {
      int dlm;

      dlm = (Frq)/(BaudRate*16);

      UART1_LCR = (int)0x80;
      UART1_SCLR  = 0;
      UART1_DLL   = dlm&0xFF;
      UART1_DLM   = (dlm>>8);
      UART1_LCR   = 3;

} // UART_conf


void UART_sendByte(char Sym) {
// пишем символ в порт
     UART1_THR = Sym;
// ждем, пока он будет отправлен
    while ( ( UART1_LSR & 0x60 ) != 0x60 ) ;
}// UART_sendByte

char UART_receiveByte() {
   char Readed_value;
 // ждем, пока на RBR что-то появится
   while ( ( UART1_LSR & 0x01) != 0x01);
   Readed_value = UART1_RBR;
   return Readed_value;
}


 void Transf(const char *Str)
 {
       while (*Str != 0)
          UART_sendByte(*Str++);
 }

void u_out (char s[],u32 a)
{
   Transf (s);
   itoa (a,strng);
// sprintf (strng,"%u",a);
   Transf(strng);
   Transf ("\r");
}

void x_out (char s[],u32 a) //НЕ РАБОТАЕТ!!!
{
   Transf (s);
   itox (a,strng);
//   sprintf (strng,"%X",a);
   Transf(strng);
   Transf ("\r");
}

void un_out (char s[],u32 a)
{
   Transf (s);
   itoa (a,strng);
// sprintf (strng,"%u",a);
   Transf(strng);
}

// функция заполняет массив нулями
void ZeroArray(unsigned int *array, unsigned int len)
{
        unsigned int i;

        for (i=0;i<len;i++) {
                array[i] = 0;
        }
}

// разрешение прерывания внутри UART
void IER_UART()
{
//	UART0_IER = UART0_IER|0x01;// ERBI Разрешение прерывания по наличию принятых данных (RDAI), а также по таймауту (CTI)
	UART1_IER = UART1_IER|0x01;// ERBI Разрешение прерывания по наличию принятых данных (RDAI), а также по таймауту (CTI)
}

char getchar0(void)
{
   u8 data;
   while (rx_counter0 == 0);
   data = rx_buffer0[ rx_rd_index0++ ];
   if (rx_rd_index0 == RX_BUFFER_SIZE0) rx_rd_index0 = 0;
    --rx_counter0;
    return data;
}


void UART_conrol (void)
{
 u16 i=0;
 u16 j=0;

  if (rx_counter0!=0u)
    {
      if (rx_counter0<BUFFER_SR) j = rx_counter0; else j=BUFFER_SR;

      for (i=0u;i<j; i++)
         {
           sr[i]=getchar0();
           lenght=i+1;
           if (sr[i]==';') {break;}
          }
            sr[lenght]=0x00;
            //Transf("*");
            IO (sr);
        };
}


u8 leng ( char *s)
{
  u8 i=0;

   while ((s[i]!='\0')&&(i<120)) { i++;}

  return i;
}

void AT1(u8 a)
{
	if (a&0x01) GPIO_DR0 |=(1<<8);else GPIO_DR0 &=(~(1<<8));
	if (a&0x02) GPIO_DR0 |=(1<<9);else GPIO_DR0 &=(~(1<<9));

	if (a&0x04) GPIO_DR0 |=(1<<0);else GPIO_DR0 &=(~(1<<0));
	if (a&0x08) GPIO_DR0 |=(1<<1);else GPIO_DR0 &=(~(1<<1));

	if (a&0x10) GPIO_DR2 |=(1<<5);else GPIO_DR2 &=(~(1<<5));
	if (a&0x20) GPIO_DR2 |=(1<<6);else GPIO_DR2 &=(~(1<<6));
}

void AT2(u8 a)
{
	if (a&0x01) GPIO_DR0 |=(1<<2);else GPIO_DR0 &=(~(1<<2));
	if (a&0x02) GPIO_DR0 |=(1<<3);else GPIO_DR0 &=(~(1<<3));

	if (a&0x04) GPIO_DR0 |=(1<<4);else GPIO_DR0 &=(~(1<<4));
	if (a&0x08) GPIO_DR0 |=(1<<5);else GPIO_DR0 &=(~(1<<5));

	if (a&0x10) GPIO_DR0 |=(1<<6);else GPIO_DR0 &=(~(1<<6));
	if (a&0x20) GPIO_DR0 |=(1<<7);else GPIO_DR0 &=(~(1<<7));
}

void MFBSP0_init ()//режим порта ввода-вывода общего назначения
{
//	TX_MFBSP0
//	RX_MFBSP0

	CSR_MFBSP0=0;//Регистр управления и состояния
	CSR_MFBSP0|=(0x00)|//LEN В режиме I2S должен быть установлен в 0
				(0<< 1)|//LTRAN
				(0<< 2)|//-----
				(0<< 3)|//LSTAT read only
				(0<< 9)|//SPI_I2S_EN  0 – Работа в режиме LPORT  1 – Работа в режиме SPI/I2S
				(0<<15)|//Разрешение прерывания MFBSP_RXBUF:0 – прерывание запрещено;1- прерывание разрешено.
				(0<<16)|//Разрешение прерывания MFBSP_TXBUF:0 – прерывание запрещено;1- прерывание разрешено.
				(0<<30)|//TX_RDY_MODE
				(0<<31);//RX_RDY_MODE

	DIR_MFBSP0=0x3ff;//все выходы
	GPIO_DR0  =0x000;

	TCTR0     =0;     //далее для - режим SPI
	TCTR0    |=(0<< 0)|//TEN Разрешение работы передатчика:
			   (0<< 1)|//TMODE  Режим работы передатчика:0 – режим I2S;1 – режим SPI
			   (0<< 3)|//SS_DO управление выводами SS ;0 – управление выводами SS производится в автоматическом режиме.
			   (0<< 9)|//TDSPMODE Формат передачи данных:0 – передача в формате I2S;1 – передача в формате DSP
			   (0<<10)|//TNEG Полярность тактового сигнала передатчика (эквивалентно CPOL в спецификации Motorola)
			   (0<<11)|//TDEL Задержка начала передачи данных на такт  (Эквивалентно CPHA в спецификации Motorola)
			   (0<<19)|//TMBF Порядок передачи бит:0 – младшим битом вперед;1 – старшим битом вперед
			   (0<<20)|//TWORDLEN Длина передаваемого слова:Число бит в передаваемом слове равно TWORDLEN + 1.TWORDLEN должно быть больше 0.
			   (0<<30)|//SS[0] биты управления шиной Slave Select:Позволяет активировать подключенное ведомое устройство.
					  //При SS_DO = 0 установка соответствующего бита SS в 1
					  //означает выбор ведомого устройства, с которым будет
					  //производится обмен данными
					  //При SS_DO = 1 значения бит SS передаются на выводы
					  //SS напрямую
			   (0<<31);//SS[1]  При SS_DO = 1 значение бита SS передаются на вывод LDAT[0]

	RCTR0	 =0;
	RCTR0	|=(0x00)|//REN Разрешение работы приёмника:0 – приемник выключен 1 – приемник включен
			  (0<< 1)|//RMODE Режим работы приёмника:0 – режим I2S 1 – режим SPI
			  (0<< 2)|//RCLK_CP Дублирование сигнала RSCK:0 – RSCK формируется или принимается независимо от передатчика
					 // 1 – RSCK приёмника дублирует TSCK передатчика (в этом случае RCS_CP должно быть так же в 1).
			  (0<< 3)|//RCS_CP Управление сигналом выбора ведомого приёмника:0 – сигнал SS[1] принимается приёмником с внешнеговывода или формируется самим приёмником
			  (0<<10)|//RNEG Полярность тактового сигнала приёмника:(эквивалентно CPOL в спецификации Motorola).
			  (0<<11)|//RDEL Задержка начала приёма данных на пол такта:(Эквивалентно CPHA в спецификации Motorola).
			  (0<<19)|//RMBF Порядок передачи бит:0 – младшим битом вперед 1 – старшим битом вперед
			  (0<<20);//RWORDLEN Длина принимаемого слова:Число бит в принимаемом слове равно RWORDLEN + 1. RWORDLEN должно быть больше 0


	TSR0	=0;//Регистр состояния передатчика TSR (режим SPI)
	TSR0   |=0;

	RSR0    =0;// Регистр состояния приёмника RSR (режим SPI)
}

//  LPORT
// Частота CPU в Гц
#define FREQ 240000000

// Частота LPORT в Гц
#define LPORT_FRQ 20000000

// длина массива в 32-разрядных словах
#define ARRAY_LEN_lport 1024

// Адреса массивов должны быть выравнены по границе 64-разрядного слова,
// если они будут пересылаться по DMA
unsigned int lport_OutputArray[ARRAY_LEN_lport] __attribute__ ((aligned (8)));
unsigned int lport_InputArray[ARRAY_LEN_lport] __attribute__ ((aligned (8)));

unsigned int flag_DMA_LPORT=0;

// установка значения регистра CP0 Status
void SetCP0_Status(unsigned int value)
{
  asm volatile ("mtc0 %0, $12" ::"r"(value));
}


// настройка режима размещения векторов прерываний TR_CRAM во внутренней памяти
void TR_CRAM_set()
{
   //  CSR |= (1<<1);   //TR_CRAM
}

// установка регистра MASKR2 на прерывание
void MASKR2_set()
{
    // настраиваем регистр маски прерываний (MASKR2)
    // выставляем разряд MASKR2[29], разрешающий прерывание от DMA канала
    MASKR2 |= (1<<7);
}


// функция обработчика
void ID1_LPORT_handler()
{

//---------DMA порта MFBSP---------
unsigned int ActiveIRQ;
unsigned int tmp_read;

    ActiveIRQ = QSTR2 & MASKR2;
    if ( (ActiveIRQ & (1<<7)) != 0 )
	{  // Если это прерывание от канала DMA порта MFBSP1 при приеме данных
    // сбрасываем биты DONE и END регистров управления и состояния DMA портов, чтобы снять прерывание
       tmp_read = CSR_MFBSP_RX_CH1;
//      tmp_read = CSR_MFBSP_TX_CH1;
       flag_DMA_LPORT = 1;    //  флаг завершения обработки прерывания
    }
}

// функция обработчика
void int_handler()
{
//---------UART--------------------
    tmp_read = UART1_IIR;

   rx_buffer0[rx_wr_index0++]= UART1_RBR; //считываем данные в буфер, инкрементируя хвост буфера
   if ( rx_wr_index0 == RX_BUFFER_SIZE0) rx_wr_index0=0; //идем по кругу

    if (++rx_counter0 == RX_BUFFER_SIZE0) //переполнение буфера
      {
        rx_counter0=0; //начинаем сначала (удаляем все данные)
        rx_buffer_overflow0=1;  //сообщаем о переполнении
      }
}


void MFBSP1_init ()//режим порта LPORT
{
   unsigned int LCLK_RATE;

   LCLK_RATE = (FREQ/(2*LPORT_FRQ)) - 1;

//	TX_MFBSP1
//	RX_MFBSP1

	CSR_MFBSP1=0;//Регистр управления и состояния
	CSR_MFBSP1|=(0x01)|//LEN В режиме Линковый порт(LPORT)
				(0<< 1)|//LTRAN 0 – приемник;
    ((LCLK_RATE&1)<< 2)|//LCLK_RATE[0] Делитель частоты LPORT:LCLK = CLK/(2*(LCLK_RATE+1))
				(0<< 3)|//LSTAT read only
				(0<< 5)|//LRERR read only Ошибка приема данных.
				(1<< 6)|//LDW Разрядность внешней шины данных:1 - 8-разряда (32-разрядное слово передается за 4 посылки).
				(0<< 7)|//SRQ_TX Признак запроса обслуживания на передачу данных
				(0<< 8)|//SRQ_RX Признак запроса обслуживания на прием данных
				(0<< 9)|//SPI_I2S_EN  0 – Работа в режиме LPORT  1 – Работа в режиме SPI/I2S
				(0<<10)|//LPT_IRQ_EN Разрешение прерывания SRQ:1 – прерывания по запросу обслуживания LPORT разрешены
 ((LCLK_RATE&0x1e)<<11)|//LCLK_RATE[4:1] Делитель частоты LPORT:LCLK = CLK/(2*(LCLK_RATE+1))
				(0<<15)|//Разрешение прерывания MFBSP_RXBUF:0 – прерывание запрещено;1- прерывание разрешено.
				(0<<16)|//Разрешение прерывания MFBSP_TXBUF:0 – прерывание запрещено;1- прерывание разрешено.
				(0<<30)|//TX_RDY_MODE Режим формирования признака готовности передачи данных из MFBSP в DMA:
				(0<<31);//RX_RDY_MODE Режим формирования признака готовности приема данных из DMA в MFBSP:

	DIR_MFBSP1=0x001;//LACK - выход, остальные входы
	GPIO_DR1  =0x000;

	TCTR1     =0;     //далее для - режим SPI
	TCTR1    |=(0<< 0)|//TEN Разрешение работы передатчика:
			   (0<< 1)|//TMODE  Режим работы передатчика:0 – режим I2S;1 – режим SPI
			   (0<< 3)|//SS_DO управление выводами SS ;0 – управление выводами SS производится в автоматическом режиме.
			   (0<< 9)|//TDSPMODE Формат передачи данных:0 – передача в формате I2S;1 – передача в формате DSP
			   (0<<10)|//TNEG Полярность тактового сигнала передатчика (эквивалентно CPOL в спецификации Motorola)
			   (0<<11)|//TDEL Задержка начала передачи данных на такт  (Эквивалентно CPHA в спецификации Motorola)
			   (0<<19)|//TMBF Порядок передачи бит:0 – младшим битом вперед;1 – старшим битом вперед
			   (0<<20)|//TWORDLEN Длина передаваемого слова:Число бит в передаваемом слове равно TWORDLEN + 1.TWORDLEN должно быть больше 0.
			   (0<<30)|//SS[0] биты управления шиной Slave Select:Позволяет активировать подключенное ведомое устройство.
					  //При SS_DO = 0 установка соответствующего бита SS в 1
					  //означает выбор ведомого устройства, с которым будет
					  //производится обмен данными
					  //При SS_DO = 1 значения бит SS передаются на выводы
					  //SS напрямую
			   (0<<31);//SS[1]  При SS_DO = 1 значение бита SS передаются на вывод LDAT[0]

	RCTR1	 =0;
	RCTR1	|=(0x00)|//REN Разрешение работы приёмника:0 – приемник выключен 1 – приемник включен
			  (0<< 1)|//RMODE Режим работы приёмника:0 – режим I2S 1 – режим SPI
			  (0<< 2)|//RCLK_CP Дублирование сигнала RSCK:0 – RSCK формируется или принимается независимо от передатчика
					 // 1 – RSCK приёмника дублирует TSCK передатчика (в этом случае RCS_CP должно быть так же в 1).
			  (0<< 3)|//RCS_CP Управление сигналом выбора ведомого приёмника:0 – сигнал SS[1] принимается приёмником с внешнеговывода или формируется самим приёмником
			  (0<<10)|//RNEG Полярность тактового сигнала приёмника:(эквивалентно CPOL в спецификации Motorola).
			  (0<<11)|//RDEL Задержка начала приёма данных на пол такта:(Эквивалентно CPHA в спецификации Motorola).
			  (0<<19)|//RMBF Порядок передачи бит:0 – младшим битом вперед 1 – старшим битом вперед
			  (0<<20);//RWORDLEN Длина принимаемого слова:Число бит в принимаемом слове равно RWORDLEN + 1. RWORDLEN должно быть больше 0


	TSR1	=0;//Регистр состояния передатчика TSR (режим SPI)
	TSR1   |=0;

	RSR1    =0;// Регистр состояния приёмника RSR (режим SPI)
}

void MFBSP2_init ()//режим порта SPI + ввода-вывода общего назначения
{
//	TX_MFBSP1
//	RX_MFBSP1

	CSR_MFBSP2=0;//Регистр управления и состояния
	CSR_MFBSP2|=(0x00)|//LEN В режиме SPI
				(0<< 1)|//LTRAN 0 – приемник;
				(0<< 2)|//LCLK_RATE[0] Делитель частоты LPORT:LCLK = CLK/(2*(LCLK_RATE+1))
				(0<< 3)|//LSTAT read only
				(0<< 5)|//LRERR read only Ошибка приема данных.
				(1<< 6)|//LDW Разрядность внешней шины данных:1 - 8-разряда (32-разрядное слово передается за 4 посылки).
				(0<< 7)|//SRQ_TX Признак запроса обслуживания на передачу данных
				(0<< 8)|//SRQ_RX Признак запроса обслуживания на прием данных
				(0<< 9)|//SPI_I2S_EN  0 – Работа в режиме LPORT  1 – Работа в режиме SPI/I2S
				(0<<10)|//LPT_IRQ_EN Разрешение прерывания SRQ:1 – прерывания по запросу обслуживания LPORT разрешены
				(0<<11)|//LCLK_RATE[4:1] Делитель частоты LPORT:LCLK = CLK/(2*(LCLK_RATE+1))
				(0<<15)|//Разрешение прерывания MFBSP_RXBUF:0 – прерывание запрещено;1- прерывание разрешено.
				(0<<16)|//Разрешение прерывания MFBSP_TXBUF:0 – прерывание запрещено;1- прерывание разрешено.
				(0<<30)|//TX_RDY_MODE Режим формирования признака готовности передачи данных из MFBSP в DMA:
				(0<<31);//RX_RDY_MODE Режим формирования признака готовности приема данных из DMA в MFBSP:

	DIR_MFBSP2 =0;//

	DIR_MFBSP2|=(0x00)|
				(0<< 0)|//Направление вывода RSCK:0 – RSCK – вход (тактовый сигнал RSCK принимается от внешнего источника)
				(0<< 1)|//Направление вывода TSCK:1 – TSCK – выход (тактовый сигнал TSCK формируется передатчиком)
				(1<< 2)|//Направление вывода SS[1]
				(1<< 3)|//Направление вывода SS[0] 1 – SS[0] - выход, управляющий сигнал формируется передатчиком
				(0<< 4)|//Направление вывода MISO:0 – MISO – вход (последовательные данные принимаются со входа MISO - эквивалент SDI)
				(1<< 5)|//Направление вывода MOSI:1 – MOSI - выход (MOSI – является выходом для передачи последовательных данных и является эквивалентом SDO)
				(1<< 6)|//PWRDWN_A2
				(1<< 7)|//AT1_5
				(1<< 8)|//AT1_6
				(1<< 9);//PF1_SYNC_START


	GPIO_DR2  =0x03f;

	TCTR2     =0;     //далее для - режим SPI
	TCTR2    |=(1<< 0)|//TEN Разрешение работы передатчика:
			   (1<< 1)|//TMODE  Режим работы передатчика:0 – режим I2S;1 – режим SPI
			   (0<< 3)|//SS_DO управление выводами SS ;0 – управление выводами SS производится в автоматическом режиме.
			   (0<< 9)|//TDSPMODE Формат передачи данных:0 – передача в формате I2S;1 – передача в формате DSP
			   (0<<10)|//TNEG Полярность тактового сигнала передатчика (эквивалентно CPOL в спецификации Motorola)
			   (0<<11)|//TDEL Задержка начала передачи данных на такт  (Эквивалентно CPHA в спецификации Motorola)
			   (1<<19)|//TMBF Порядок передачи бит:0 – младшим битом вперед;1 – старшим битом вперед
			   (0<<20)|//TWORDLEN Длина передаваемого слова:Число бит в передаваемом слове равно TWORDLEN + 1.TWORDLEN должно быть больше 0.
			   (0<<30)|//SS[0] биты управления шиной Slave Select:Позволяет активировать подключенное ведомое устройство.
					  //При SS_DO = 0 установка соответствующего бита SS в 1
					  //означает выбор ведомого устройства, с которым будет
					  //производится обмен данными
					  //При SS_DO = 1 значения бит SS передаются на выводы
					  //SS напрямую
			   (0<<31);//SS[1]  При SS_DO = 1 значение бита SS передаются на вывод LDAT[0]

	RCTR2	 =0;
	RCTR2	|=(0x01)|//REN Разрешение работы приёмника:0 – приемник выключен 1 – приемник включен
			  (1<< 1)|//RMODE Режим работы приёмника:0 – режим I2S 1 – режим SPI
			  (1<< 2)|//RCLK_CP Дублирование сигнала RSCK:0 – RSCK формируется или принимается независимо от передатчика
					 // 1 – RSCK приёмника дублирует TSCK передатчика (в этом случае RCS_CP должно быть так же в 1).
			  (1<< 3)|//RCS_CP Управление сигналом выбора ведомого приёмника:0 – сигнал SS[1] принимается приёмником с внешнеговывода или формируется самим приёмником
			  (0<<10)|//RNEG Полярность тактового сигнала приёмника:(эквивалентно CPOL в спецификации Motorola).
			  (0<<11)|//RDEL Задержка начала приёма данных на пол такта:(Эквивалентно CPHA в спецификации Motorola).
			  (1<<19)|//RMBF Порядок передачи бит:0 – младшим битом вперед 1 – старшим битом вперед
			  (7<<20);//RWORDLEN Длина принимаемого слова:Число бит в принимаемом слове равно RWORDLEN + 1. RWORDLEN должно быть больше 0


	TSR2	=0;//Регистр состояния передатчика TSR (режим SPI)
	TSR2   |=0;

	RSR2    =0;// Регистр состояния приёмника RSR (режим SPI)
}

void MFBSP3_init ()//режим порта SPI + ввода-вывода общего назначения
{
//	TX_MFBSP1
//	RX_MFBSP1

u16 l=0;

// DIR_MFBSP3 = 0xff;   // переключаем LDAT[7:0] в режим выхода
// GPIO_DR3   = 0xff;   // регистр данных
/*
	CSR_MFBSP3=0;//Регистр управления и состояния

	CSR_MFBSP3|=(0x00)|//LEN В режиме SPI
				(0<< 1)|//LTRAN 0 – приемник;
				(0<< 2)|//LCLK_RATE[0] Делитель частоты LPORT:LCLK = CLK/(2*(LCLK_RATE+1))
				(0<< 3)|//LSTAT read only
				(0<< 5)|//LRERR read only Ошибка приема данных.
				(1<< 6)|//LDW Разрядность внешней шины данных:1 - 8-разряда (32-разрядное слово передается за 4 посылки).
				(0<< 7)|//SRQ_TX Признак запроса обслуживания на передачу данных
				(0<< 8)|//SRQ_RX Признак запроса обслуживания на прием данных
				(0<< 9)|//SPI_I2S_EN  0 – Работа в режиме LPORT  1 – Работа в режиме SPI/I2S
				(0<<10)|//LPT_IRQ_EN Разрешение прерывания SRQ:1 – прерывания по запросу обслуживания LPORT разрешены
				(0<<11)|//LCLK_RATE[4:1] Делитель частоты LPORT:LCLK = CLK/(2*(LCLK_RATE+1))
				(0<<15)|//Разрешение прерывания MFBSP_RXBUF:0 – прерывание запрещено;1- прерывание разрешено.
				(0<<16)|//Разрешение прерывания MFBSP_TXBUF:0 – прерывание запрещено;1- прерывание разрешено.
				(0<<30)|//TX_RDY_MODE Режим формирования признака готовности передачи данных из MFBSP в DMA:
				(0<<31);//RX_RDY_MODE Режим формирования признака готовности приема данных из DMA в MFBSP:
				*/

//	DIR_MFBSP3 =0x26c;//
		


	DIR_MFBSP3 |=
				(1<< 0)|//Направление вывода RSCK:0 – RSCK – вход (тактовый сигнал RSCK принимается от внешнего источника)
				(1<< 1)|//Направление вывода TSCK:1 – TSCK – выход (тактовый сигнал TSCK формируется передатчиком)
				(1<< 2)|//Направление вывода SS[1]
				(1<< 3)|//Направление вывода SS[0] 1 – SS[0] - выход, управляющий сигнал формируется передатчиком
				(0<< 4)|//Направление вывода MISO:0 – MISO – вход (последовательные данные принимаются со входа MISO - эквивалент SDI)
				(1<< 5)|//Направление вывода MOSI:1 – MOSI - выход (MOSI – является выходом для передачи последовательных данных и является эквивалентом SDO)
				(1<< 6)|//PWRDWN_A1
				(0<< 7)|//NA
				(0<< 8)|//NA
				(1<< 9);//RST_1288


	GPIO_DR3  =0x0ff;
	
//			 x_out("l=",l);
/*
	TCTR3     =0;     //далее для - режим SPI

	TCTR3    |=(1<< 0)|//TEN Разрешение работы передатчика:
			   (1<< 1)|//TMODE  Режим работы передатчика:0 – режим I2S;1 – режим SPI
			   (1<< 3)|//SS_DO  значения бит SS напрямую передаются на внешние выводы.
			   (0<< 9)|//TDSPMODE Формат передачи данных:0 – передача в формате I2S;1 – передача в формате DSP
			   (0<<10)|//TNEG Полярность тактового сигнала передатчика (эквивалентно CPOL в спецификации Motorola)
			   (0<<11)|//TDEL Задержка начала передачи данных на такт  (Эквивалентно CPHA в спецификации Motorola)
			   (1<<19)|//TMBF Порядок передачи бит:0 – младшим битом вперед;1 – старшим битом вперед
			   (0<<20)|//TWORDLEN Длина передаваемого слова:Число бит в передаваемом слове равно TWORDLEN + 1.TWORDLEN должно быть больше 0.
			   (0<<30)|//SS[0] биты управления шиной Slave Select:Позволяет активировать подключенное ведомое устройство.
					  //При SS_DO = 0 установка соответствующего бита SS в 1
					  //означает выбор ведомого устройства, с которым будет
					  //производится обмен данными
					  //При SS_DO = 1 значения бит SS передаются на выводы
					  //SS напрямую
			   (0<<31);//SS[1]  При SS_DO = 1 значение бита SS передаются на вывод LDAT[0]

	RCTR3	 =0;*/
/*
	RCTR3	|=(0x01)|//REN Разрешение работы приёмника:0 – приемник выключен 1 – приемник включен
			  (1<< 1)|//RMODE Режим работы приёмника:0 – режим I2S 1 – режим SPI
			  (1<< 2)|//RCLK_CP Дублирование сигнала RSCK:0 – RSCK формируется или принимается независимо от передатчика
					 // 1 – RSCK приёмника дублирует TSCK передатчика (в этом случае RCS_CP должно быть так же в 1).
			  (1<< 3)|//RCS_CP Управление сигналом выбора ведомого приёмника:0 – сигнал SS[1] принимается приёмником с внешнеговывода или формируется самим приёмником
			  (0<<10)|//RNEG Полярность тактового сигнала приёмника:(эквивалентно CPOL в спецификации Motorola).
			  (0<<11)|//RDEL Задержка начала приёма данных на пол такта:(Эквивалентно CPHA в спецификации Motorola).
			  (1<<19)|//RMBF Порядок передачи бит:0 – младшим битом вперед 1 – старшим битом вперед
			  (7<<20);//RWORDLEN Длина принимаемого слова:Число бит в принимаемом слове равно RWORDLEN + 1. RWORDLEN должно быть больше 0


	TSR3	=0;//Регистр состояния передатчика TSR (режим SPI)
	TSR3   |=0;

	RSR3    =0;// Регистр состояния приёмника RSR (режим SPI)

*/
}

void init_GPIO_DR2 (u16 a,u8 z)
{
	if (z==RESET) GPIO_DR2&=(~(a<<2)); else GPIO_DR2|=(a<<2);
}

void init_GPIO_DR3 (u16 a,u8 z)
{
	if (z==RESET) GPIO_DR3&=(~(a<<2)); else GPIO_DR3|=(a<<2);
}


void GPIO_conf()
{
 DIR_MFBSP3 = 0xff;   // переключаем LDAT[7:0] в режим выхода
 GPIO_DR3   = 0xff;   // регистр данных

// DIR_MFBSP2 = 0xfb;   // переключаем LDAT[7:0] в режим выхода
// GPIO_DR2   = 0xff;   // регистр данных
} // GPIO_conf

// диод включен
 void LED(u8 a)
{
	if ((a&0x01)==1) TST1(1); else TST1(0);
//	u_out("a:",a);
// GPIO_DR3 =a;

} //LED_on

void adc1_init (u8 a)
{
	A1_CSB(1);
	A1_SPLIN(0);

	if (a==1) A1_PWRDN(0); else	A1_PWRDN(1);
}

void adc2_init (u8 a)
{
	A2_CSB(1);
	A2_SPLIN(0);

	if (a==1) A2_PWRDN(0); else	A2_PWRDN(1);
}

void Menu1()
{
//***************************************************************************

    int i;


  for (i=0;i<20;i++) Transf("\r");    // очистка терминала
  for (i=0; i<20; i++) Transf ("-");  // вывод приветствия
  Transf("\r");
  Transf("..........Terminal Тестовой платы.........\r\n");
  Transf("\r");
  Transf("MENU :\r");
  Transf("-------\r");
  Transf("Расшифровка структуры команды:\r");
  Transf("~ - стартовый байт\r");
  Transf("1 - адрес абонента\r");
  Transf(";- конец пачки \r");
  Transf(".............. \r");
  Transf("---------------------------------------------\r\n");
  Transf("IP  :192.168.1.163 - IP адрес    блока\r");
  Transf("PORT:2054          - номер порта блока\r");
  Transf("~0 help; - текущее меню\r");
  Transf("~0 info; - информация \r");
  Transf("~0 dac1_init; - \r");
  Transf("~0 dac1_r:0;   - чтение регистра\r");
  Transf("~0 dac1_w:0.0; - запись регистра\r");
  Transf("~0 dac1_serdes_pll:1; - очистка регистра сигнала захвата PLL Serdes\r");
  Transf("~0 dac1_info:0; \r");
  Transf("~0 dac1_init:0; \r");
  Transf("~0 dac1_phy_wr:0; \r");
  Transf("~0 dac1_phy_info; \r");
  Transf("~0 lmk_sync; - sync на LMK\r");
  Transf("~0 init_lmk; - init на LMK\r");
  Transf("-------------------------------------------\r");
  Transf("\r");
  Transf("\r");
  Transf("++++++++++++++++++++\r");
  Transf("\r");
  Transf("\r");
  //for (i=0; i<64; i++) zputs ("*",1);  // вывод приветствия
  //for (i=0;i<10;i++) puts("\r",1);  // очистка терминала
  Transf("\r");
  //*******************************************************************************
}


u32 crc_input=0u;
u32 crc_comp=0u;

u32 IO ( char* str)      // функция обработки протокола обмена
{

 unsigned int i=0;

  i = lenght;//длинна принятой пачки
  if (lenght==0) i = leng(str);
  lenght = 0;
  indexZ = 0;

  while (i>0u)   //перегрузка принятого пакета в массив обработки
  {


  if ((str[indexZ]==0x7e)&&(packet_flag==0))// обнаружено начало пакета
    {
    //-------------------
    packet_flag=1;
    //-------------------
    time_uart=0u;  //обнуление счётчика тайм аута
    index1=0u;
    crc_ok=0;
    packet_ok=0;
    index_word=0u;
    index_data_word =1u;
    index_data_word2=1u;
    data_flag =0;
    data_flag2=0;
      FLAG_lenght=0u;
      lenght_data=0u;
      sch_lenght_data=0u;
    DATA_Word [0]=' ';
    DATA_Word2[0]=' ';
      FLAG_CW = 0u; //флаг управляющего байта, снимается сразу после исполнения
    FLAG_DATA = 0u;
    SCH_LENGHT_PACKET=0;

    }

   InOut[index1]=str[indexZ];
   SCH_LENGHT_PACKET++;//подсчитываем длинну пакета

  if (( InOut[index1]==';')&&(FLAG_DATA==0u)&&(packet_flag==1))  {packet_flag=0;packet_ok=1u;FLAG_CW=1u;}

  if (((InOut[index1]=='=')||(InOut[index1]==':'))&&(data_flag==0)) {data_flag=1u;FLAG_CW=1u;}

  if (( InOut[index1]=='.')&&(data_flag2==0)&&(FLAG_DATA==0))   {data_flag2=1u; FLAG_CW=1u;}

  if (( InOut[index1]=='$')&&(FLAG_lenght==0u)) {FLAG_lenght=2u;FLAG_CW=1u;}

  if ((index1>2u)&&(InOut[2]==' ')&&(FLAG_CW==0u)&&(FLAG_lenght<2u))
            {
                             if   (data_flag!=1u) {Word[index_word]=InOut[index1];} // заполняем командное слово

                             if  ((data_flag==1u)&&(data_flag2==0u))     DATA_Word[index_data_word]=InOut[index1];// заполняем  слово данных1
                             if  ((data_flag==1u)&&(data_flag2==1u))     DATA_Word2[index_data_word2]=InOut[index1]; // заполняем  слово данных2

                             if  (data_flag!=1u)
                                     {if (index_word<buf_Word) index_word++;}
                                   else
                                            {
                                             if ((data_flag==1u)&&(data_flag2==0u)) if (index_data_word<buf_DATA_Word)  {index_data_word++;sch_lenght_data++;}

                                             if ((data_flag==1u)&&(data_flag2==1u)) if (index_data_word2<buf_DATA_Word) index_data_word2++;
                                            }
      }

    if ((FLAG_lenght==2u)&&(FLAG_CW==0u)) {lenght_data = (u8)(InOut[index1]);FLAG_lenght=1u;} //запоминаем длинну пакета данных после ":"

    if ((sch_lenght_data<lenght_data)&&(FLAG_lenght==1u)) FLAG_DATA = 1u; else {FLAG_DATA = 0u;}

    if (index1<BUFFER_SR)  index1++;
    if (indexZ <BUFFER_SR)  indexZ ++;
    i--;
    FLAG_CW=0u;

  }


if (packet_ok==1u)
  {
      if (InOut[0]==0x7e)   crc_ok=crc_ok|0x1;   // проверка первого условия пакета - начало пакета
      if (InOut[1]==Adress) crc_ok=crc_ok|0x2;   // проверка второго условия пакета - адресат назначения

if (crc_ok==0x3)  //обработка команд адресатом которых является хозяин
{

if (strcmp(Word,"help")==0)
   {
     Transf ("принял help\r"    );
     Transf("\r");
     Menu1(0);
   } else
if (strcmp(Word,"help2")==0)
   {
     Transf ("принял help\r"    );
     Transf("\r");
   } else
if (strcmp(Word,"info")==0)
   {
     Transf ("принял info\r"    );
     Transf("\r");
     //info();
   } else

if (strcmp(Word,"menu")==0)
   {
     Transf ("принял menu\r"    );
     Transf("\r");
     Menu1();
   } else

 if (strcmp(Word,"init_adc1")==0) //
   {
	Transf ("----------\r"    );
	crc_comp =atoi(DATA_Word);
	u_out ("принял init_adc1:",crc_comp);
	adc1_init (crc_comp);
    } else

 if (strcmp(Word,"init_adc2")==0) //
   {
	Transf ("----------\r"    );
	crc_comp =atoi(DATA_Word);
	u_out ("принял init_adc2:",crc_comp);
	adc2_init (crc_comp);
    } else

if (strcmp(Word,"upr_at1")==0) //
   {
	crc_comp =atoi(DATA_Word);
	u_out ("принял upr_at1:",crc_comp);
    } else

if (strcmp(Word,"upr_at2")==0) //
   {
	crc_comp =atoi(DATA_Word);
	u_out ("принял upr_at2:",crc_comp);
    } else

if (strcmp(Word,"spi_w")==0) //
   {
	crc_comp =atoi(DATA_Word);  //адресс
	crc_input=atoi(DATA_Word2); //данные
	un_out ("принял spi_w:",crc_comp);
	u_out (".",crc_input);
	spi_1288_wr (crc_comp,crc_input);
   } else

if (strcmp(Word,"spi_r")==0) //
   {
	crc_comp =atoi(DATA_Word);  //адресс
	crc_input=atoi(DATA_Word2); //данные
	u_out ("принял spi_r:",crc_comp);
	x_out(">",spi_1288_rd (crc_comp));
   } else

//-------------------ADC2------------------------------
if (strcmp(Word,"adc2_read_reg")==0) //
   {
	u_out ("принял adc2_read_reg:",0);
   } else
//-------------------ADC1------------------------------
if (strcmp(Word,"adc1_read_reg")==0) //
   {
	u_out ("принял adc1_read_reg:",0);
   }
}
      for (i=0u;i<buf_Word;i++)               Word[i]     =0x0;
      for (i=0u;i<buf_DATA_Word;  i++)   DATA_Word[i]     =0x0;
      for (i=0u;i<buf_DATA_Word;  i++)  DATA_Word2[i]     =0x0;
      for (i=0u;i<BUFFER_SR;i++)
      {
        InOut[i]     =0x0;
      }

      time_uart=0;  //обнуление счётчика тайм аута
      packet_flag=0;
      index1=0u;
      crc_ok=0;
      i=0;
      packet_ok=0;
      index_word=0u;
      index_data_word=0u;
      data_flag=0;
      index_data_word2=0u;
      data_flag2=0;
      indexZ =0u;
      FLAG_lenght=0u;
      lenght_data=0u;
      sch_lenght_data=0u;
      FLAG_CW = 0u; //флаг управляющего байта, снимается сразу после исполнения
      FLAG_DATA = 0u;

      DATA_Word [0]=' ';
      DATA_Word2[0]=' ';
    SCH_LENGHT_PACKET=0;
  }

  if ((packet_ok==1)&&(crc_ok==0x1))     //обработка команд адресатом которых является слейв
  {
    if (Master_flag==0)
      {

      }
  }

  return  0;
}

int SYS_timer0=0;
int SYS_timer1=0;
int Dtimer0=0;

void Delay_ms (int a)
{
	SYS_timer0=a;
	while (SYS_timer0!=0){};
}

//-------------таймер IT0--------------------
void ID0_init (void)
{
	ITCSR0    = 0x00;
	ITPERIOD0 = 1000; //1 ms
	ITSCALE0  = 100;  //1 MHz
//	ITCOUNT0  = 0;

	ITCSR0    = ITCSR0|0x01;
}



void ID0_IT_handler ()
{
	ITCSR0    = ITCSR0&(~0x02);
	if (SYS_timer0!=0) SYS_timer0--;
	if (SYS_timer1!=0) SYS_timer1--;
	if (Dtimer0   !=0) Dtimer0   --;
//	Transf(">");
}
//---------------------------------



//---------------------------------

// частота работы SPI в Гц
unsigned int SPI_FRQ = 6000000;
// флаг корректности принятых данных
unsigned int Flag_Corr;

u32 spi (u32 a)
{
	u32 data=0;
	TX_SPI=a;                 //передача очередного значения
    while (!(CSR_SPI & 1<<4));//ожидание получения новых данных
    data=RX_SPI;              //чтение полученного значения
	return (data&0xffffff);
}

#define SETA   0x10
#define GETA   0x90
#define WR     0x20
#define WRI    0x30
#define GETD   0xa0
#define SETAFT 0xb0


u32 spi_1288_wr (u16 adr,u16 data)
{
	u32 var=0;
	var=(SETA<<16)|adr;
	spi (var);//Установка адреса во внутреннем регистре адреса порта
	var=(WR<<16)|data;
	spi (var);//Запись данных в регистр 1288ХК1Т по ранее установленному адресу
	return 0;
}

u32 spi_1288_rd (u16 adr)
{
	u32 var=0;
	u32 z=0;
	var=(SETAFT<<16)|adr;//Установка адреса во внутреннем регистре порта c выборкой значения регистра 1288ХК1Т по этому адресу во внутренний регистр данных порта
	spi (var);
	var=(GETD<<16)|0x0000;//Чтение из внутреннего регистра данных порта
	z=spi(var);
	return (z&0xffff);
}

void SPI_init ()
{
//	TX_SPI
//	RX_SPI
//	CSR_SPI
//	DIR_SPI
//	TCTR
//	RCTR
//	TSR
//	RSR

//	TX_MFBSP1
//	RX_MFBSP1

	CSR_SPI =0;//Регистр управления и состояния
	CSR_SPI|=(0x00)|//LEN В режиме SPI
				(0<< 1)|//LTRAN 0 – приемник;
				(0<< 3)|//LSTAT read only
				(1<< 9)|//SPI_I2S_EN  0 – Работа в режиме LPORT  1 – Работа в режиме SPI/I2S
				(0<<15)|//Разрешение прерывания MFBSP_RXBUF:0 – прерывание запрещено;1- прерывание разрешено.
				(0<<16)|//Разрешение прерывания MFBSP_TXBUF:0 – прерывание запрещено;1- прерывание разрешено.
				(0<<30)|//TX_RDY_MODE Режим формирования признака готовности передачи данных из MFBSP в DMA:
				(0<<31);//RX_RDY_MODE Режим формирования признака готовности приема данных из DMA в MFBSP:

	DIR_SPI =0;//
	DIR_SPI|=   (0x00)|
				(1<< 0)|//Направление вывода RSCK:0 – RSCK – вход (тактовый сигнал RSCK принимается от внешнего источника)
				(1<< 1)|//Направление вывода TSCK:1 – TSCK – выход (тактовый сигнал TSCK формируется передатчиком)
				(1<< 2)|//Направление вывода SS[1]
				(1<< 3)|//Направление вывода SS[0] 1 – SS[0] - выход, управляющий сигнал формируется передатчиком
				(0<< 4)|//Направление вывода MISO:0 – MISO – вход (последовательные данные принимаются со входа MISO - эквивалент SDI)
				(1<< 5);//Направление вывода MOSI:1 – MOSI - выход (MOSI – является выходом для передачи последовательных данных и является эквивалентом SDO)



	 TCTR     =0;     //далее для - режим SPI
	 TCTR    |=(1 << 0)|//TEN Разрешение работы передатчика:
			   (1 << 1)|//TMODE  Режим работы передатчика:0 – режим I2S;1 – режим SPI
			   (0 << 3)|//SS_DO управление выводами SS ;0 – управление выводами SS производится в автоматическом режиме.
			   (0 <<10)|//TNEG Полярность тактового сигнала передатчика (эквивалентно CPOL в спецификации Motorola)
			   (1 <<11)|//TDEL Задержка начала передачи данных на такт  (Эквивалентно CPHA в спецификации Motorola)
			   (1 <<19)|//TMBF Порядок передачи бит:0 – младшим битом вперед;1 – старшим битом вперед
			   (23<<20)|//TWORDLEN Длина передаваемого слова:Число бит в передаваемом слове равно TWORDLEN + 1.TWORDLEN должно быть больше 0.
			   (1 <<30)|//SS[0] биты управления шиной Slave Select:Позволяет активировать подключенное ведомое устройство.
					  //При SS_DO = 0 установка соответствующего бита SS в 1
					  //означает выбор ведомого устройства, с которым будет
					  //производится обмен данными
					  //При SS_DO = 1 значения бит SS передаются на выводы
					  //SS напрямую
			   (0<<31);//SS[1]  При SS_DO = 1 значение бита SS передаются на вывод LDAT[0]

	RCTR	 =0;
	RCTR	|=(0x01)|//REN Разрешение работы приёмника:0 – приемник выключен 1 – приемник включен
			  (1 << 1)|//RMODE Режим работы приёмника:0 – режим I2S 1 – режим SPI
			  (1 << 2)|//RCLK_CP Дублирование сигнала RSCK:0 – RSCK формируется или принимается независимо от передатчика
					 // 1 – RSCK приёмника дублирует TSCK передатчика (в этом случае RCS_CP должно быть так же в 1).
			  (1 << 3)|//RCS_CP Управление сигналом выбора ведомого приёмника:0 – сигнал SS[1] принимается приёмником с внешнеговывода или формируется самим приёмником
			  (0 <<10)|//RNEG Полярность тактового сигнала приёмника:(эквивалентно CPOL в спецификации Motorola).
			  (0 <<11)|//RDEL Задержка начала приёма данных на пол такта:(Эквивалентно CPHA в спецификации Motorola).
			  (1 <<19)|//RMBF Порядок передачи бит:0 – младшим битом вперед 1 – старшим битом вперед
			  (23<<20);//RWORDLEN Длина принимаемого слова:Число бит в принимаемом слове равно RWORDLEN + 1. RWORDLEN должно быть больше 0



	TSR  	=0;//Регистр состояния передатчика TSR (режим SPI)
	TSR    |=0;

	RSR     =0;// Регистр состояния приёмника RSR (режим SPI)
}


int sch;

void main()
{
char temp_z0=0;
 //---------------------------------------------------
char readed;
        CLK_EN = 0xFFFFFFFF; // включение тактовой частоты
        CR_PLL0 = 0xb01298;  // коэффициент умножения входной частоты PLL_DSP - 48   (240 МГц)
                             // коэффициент умножения входной частоты PLL_MPORT - 18 (90 МГц)
                             // коэффициент умножения входной частоты PLL_CORE - 48  (240 МГц)
 UART1_conf(115200,120000000);

// SetCP0_Status(0x1001);  // установка регистра Status на прерывание от DMA канала
// MASKR2_set();

// MFBSP0_init();
// MFBSP1_init();//режим порта LPORT
//   MFBSP2_init();//режим порта SPI + ввода-вывода общего назначения
   MFBSP3_init();//режим порта SPI + ввода-вывода общего назначения
//   SPI_init();
// GPIO_conf();
  LED(temp_z0);
//------------настройки LPORT---------
/*
// Настраиваем DMA LPORT1 на прием
    IR_MFBSP_RX_CH1  = ((unsigned int) &lport_InputArray[0]) - 0xA0000000; // записываем физический адрес в регистр индекса
    CSR_MFBSP_RX_CH1 =      (((ARRAY_LEN_lport/2)-1)<<16) | // WCX = LEN/2
                             (15<<2)   |          // WN = 15 (размер пачки - 16 слов)
                              1;                  // RUN = 1

*/
 //***********************************

 Transf("-----------------------\n\r");
 Transf("-   Многоцветник-54   -\n\r");
 Transf("-----------------------\n\r");

 Adress=0x30; //адресс кассеты
 sch=0;

 rx_counter0 =0;
 rx_rd_index0=0;
 rx_wr_index0=0;
 rx_buffer_overflow0=0;

//-------------сброс аттенюаторов----------------------
//AT1(0);
//AT2(0);
//-----------------------------------------------------
  risc_set_interrupts_vector(INTH_80000180);//INTH_80000180
  SYS_CSR |= 2;
  risc_register_interrupt(int_handler, RISC_INT_UART1);
  IER_UART();
  risc_enable_interrupt(RISC_INT_UART1);
//-----------------------------------------------------

  ID0_init ();
  risc_register_interrupt(ID0_IT_handler, RISC_INT_IT0);
  risc_enable_interrupt(RISC_INT_IT0);
//-----------------------------------------------------

//  risc_register_interrupt(ID1_LPORT_handler, RISC_INT_DMA_MFBSP1);
//  risc_enable_interrupt(RISC_INT_DMA_MFBSP1);
//-----------------------------------------------------
/*
  Transf("инициализируем SPACEWARE\r\n");

  risc_set_interrupts_vector(INTH_80000180);
  SYS_CSR |= 2;

  risc_register_interrupt(timer_hnlr, RISC_COMPARE);
  // Работаем без прерываний от gsw
  assign_dma_rx_desc((struct DMA_PORT_CH_cl *) 0xb82fa800);
  assign_dma_rx_data((struct DMA_PORT_CH_cl *) 0xb82fa840);
  assign_dma_tx_desc((struct DMA_PORT_CH_cl *) 0xb82fa880);
  assign_dma_tx_data((struct DMA_PORT_CH_cl *) 0xb82fa8C0);

  // запускаем подсчёт времени для таймаута
  unsigned int param = get_cpu_clock();
  param *= 5;
  asm volatile ("mtc0 %0, $11" : : "r"(param));
  param= 0;
  asm volatile ("mtc0 %0, $9" : : "r"(param));

  risc_enable_interrupt(RISC_COMPARE);

  int transmitter, receiver;
  transmitter = 0;
  receiver = 1;
  //SWIC_Speed = SPW_SPEED_MIN;

  // Подготовка соединений
  // cable_test_start
  unmask_irq(gigaspwr_irq_all);
  form_routing_table(false);
  gspwr_form_adg();
  set_transmit_speed(port_spw0, 5, true);
  set_transmit_speed(port_spw1, 5, true);
  set_recive_speed(port_gigaspw2, gigasw_speed_125_mhz);
  set_transmit_speed(port_gigaspw3, gigasw_speed_125_mhz, true);
  set_recive_speed(port_gigaspw3, gigasw_speed_125_mhz);
  set_transmit_speed(port_gigaspw2, gigasw_speed_125_mhz, true);
  REGS->SPW_MODE[port_gigaspw2] = SET_GIGASPWR_SPW_MODE_CODEC_LOOPBACK(REGS->SPW_MODE[port_gigaspw2], 1);
  REGS->SPW_MODE[port_gigaspw3] = SET_GIGASPWR_SPW_MODE_CODEC_LOOPBACK(REGS->SPW_MODE[port_gigaspw3], 1);


  // Это делаем по другому алгоритму
  //memory_agent.fill_mem_block_rand(TX_Data, TX_DATA_LENGTH << 1, rand()); // генерация пакета (ов?)
  //TX_Data[0] = 0;                        // always to conf port           // ?
  //TX_Data[TX_DATA_LENGTH >> 2] = 0;        // always to conf port         // в словах?
  //make_desc(TX_Desc, TX_DATA_LENGTH, route_mask_spw0);
  //make_desc(&TX_Desc[2], TX_DATA_LENGTH, route_mask_spw1);

  set_dma_enabled(true);
  set_work_enabled(true);

  start_connect(port_spw0);
  start_connect(port_spw1);
  start_connect(port_gigaspw2);
  start_connect(port_gigaspw3);

  // Ожидание соединения
Transf("ожидание соединение по spaceware\r\n");

  int port_i;
  for (port_i = port_spw0; port_i <= port_spw1; port_i++)
     if (SPW_SPEC_CABLE_PORTS & (1 << port_i))
        {
	wait_link_status(port_i, link_status_run, 1000);
        }
  speed = SWIC_Speed;

Transf("этап 1\r\n");

  //,# Для Spw переход на рабочую скорость
  // Скорость передачи устанавливаем один раз
  for (port_i = port_spw0; port_i <= port_spw1; port_i++)
      if (SPW_SPEC_CABLE_PORTS & (1 << port_i))
          set_transmit_speed(port_i, speed, true);
/*
Transf("этап 2\r\n");
  //,# Ожидание разгона PLL
  for (port_i = port_spw0; port_i <= port_spw1; port_i++)
       if (SPW_SPEC_CABLE_PORTS & (1 << port_i)) {
         while (get_rx_speed(port_i) < speed - 3){};
         //,# Проверка, что соединение не разорвалось
         errors += check_SpW_link_status_run((GIGASPWR_cl*)0, port_i);
       }
  if (errors)
      {
      Flag_Corr = 1; // соединение разорвалось
      //asm volatile("break 0x0, 0x1");
      }

Transf("этап 3\r\n");
  // cable_test_end

  risc_disable_interrupt(RISC_COMPARE);

  int size = ARRAY_LEN*sizeof(int);
  int i=0;
  int corr_counter = 0;


  unsigned int descr[2]__attribute__ ((aligned(8))) = {0};

  int l_port;
  for (i=0; i<SWIC_Number; i++)
  {
      swic_receiver_run(receiver, InputArray, descr, 0xFFFF);    // +
      FillArray(OutputArray,ARRAY_LEN,i);                        // +
      if (transmitter)
          l_port = route_mask_spw1;
      else
          l_port = route_mask_spw0;
      swic_send_packet(l_port, OutputArray, size, 1);            // +
      swic_receiver_wait(receiver);                              // + // - port check?
      corr_counter += VerifyArray(InputArray,ARRAY_LEN,i);       // +
      transmitter ^= 1;
      receiver ^= 1;
  }
 */
 Transf("------------------------\n\r");
 Transf("-        THE END       -\n\r");
 Transf("------------------------\n\r");

      while (1)
  {
    UART_conrol();

	if (flag_DMA_LPORT==1) {flag_DMA_LPORT=0; Transf("DMA LPORT!\r\n");};

	 if (Dtimer0==0) {temp_z0=~temp_z0; LED(temp_z0); Dtimer0=500;};
  }

 // if (corr_counter == SWIC_Number) Flag_Corr = 0;
 // asm volatile("break 0x0, 0x1");
}

